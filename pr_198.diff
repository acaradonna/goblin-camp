diff --git a/Cargo.lock b/Cargo.lock
index b75b98e..18d9b62 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -118,6 +118,12 @@ version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"
 
+[[package]]
+name = "base64"
+version = "0.21.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
+
 [[package]]
 name = "bevy_ecs"
 version = "0.14.2"
@@ -238,6 +244,9 @@ name = "bitflags"
 version = "2.9.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34efbcccd345379ca2868b2b2c9d3782e9cc58ba87bc7d79d5b53d9c9ae6f25d"
+dependencies = [
+ "serde",
+]
 
 [[package]]
 name = "bumpalo"
@@ -593,11 +602,13 @@ name = "gc_core"
 version = "0.1.0"
 dependencies = [
  "bevy_ecs",
+ "ciborium",
  "criterion",
  "lru",
  "noise",
  "pathfinding",
  "rand",
+ "ron",
  "serde",
  "serde_json",
  "thiserror 1.0.69",
@@ -1110,6 +1121,18 @@ version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"
 
+[[package]]
+name = "ron"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b91f7eff05f748767f183df4320a63d6936e9c6107d97c9e6bdd9784f4289c94"
+dependencies = [
+ "base64",
+ "bitflags",
+ "serde",
+ "serde_derive",
+]
+
 [[package]]
 name = "rustc-hash"
 version = "2.1.1"
diff --git a/crates/gc_cli/src/main.rs b/crates/gc_cli/src/main.rs
index 7015c5c..cd0219d 100644
--- a/crates/gc_cli/src/main.rs
+++ b/crates/gc_cli/src/main.rs
@@ -50,6 +50,10 @@ struct Args {
     #[arg(long, default_value_t = false)]
     show_vis: bool,
 
+    /// Codec for save/load demo: json|ron|cbor (default: json)
+    #[arg(long, default_value = "json")]
+    codec: String,
+
     /// Choose a demo to run. If omitted or set to `menu`, an interactive picker is shown.
     #[command(subcommand)]
     demo: Option<Demo>,
@@ -330,16 +334,49 @@ fn run_demo_jobs(args: &Args) -> Result<()> {
 fn run_demo_save(args: &Args) -> Result<()> {
     let mut world = build_world(args);
     let save = save_world(&mut world);
-    let json = serde_json::to_string(&save)?;
-    println!("Serialized save length: {} bytes", json.len());
-    let parsed: save::SaveGame = serde_json::from_str(&json)?;
-    let mut world2 = World::new();
-    load_world(parsed, &mut world2);
-    println!(
-        "Reloaded world with {}x{} map.",
-        world2.resource::<GameMap>().width,
-        world2.resource::<GameMap>().height
-    );
+    match args.codec.as_str() {
+        "json" => {
+            let data = save::encode_json(&save)?;
+            println!("Serialized (json) length: {} bytes", data.len());
+            let parsed: save::SaveGame = save::decode_json(&data)?;
+            let mut world2 = World::new();
+            load_world(parsed, &mut world2);
+            println!(
+                "Reloaded world with {}x{} map.",
+                world2.resource::<GameMap>().width,
+                world2.resource::<GameMap>().height
+            );
+        }
+        "ron" => {
+            let data = save::encode_ron(&save).map_err(|e| anyhow::anyhow!(e))?;
+            println!("Serialized (ron) length: {} bytes", data.len());
+            let parsed: save::SaveGame = save::decode_ron(&data).map_err(|e| anyhow::anyhow!(e))?;
+            let mut world2 = World::new();
+            load_world(parsed, &mut world2);
+            println!(
+                "Reloaded world with {}x{} map.",
+                world2.resource::<GameMap>().width,
+                world2.resource::<GameMap>().height
+            );
+        }
+        "cbor" => {
+            let bytes = save::encode_cbor(&save).map_err(|e| anyhow::anyhow!(e))?;
+            println!("Serialized (cbor) length: {} bytes", bytes.len());
+            let parsed: save::SaveGame =
+                save::decode_cbor(&bytes).map_err(|e| anyhow::anyhow!(e))?;
+            let mut world2 = World::new();
+            load_world(parsed, &mut world2);
+            println!(
+                "Reloaded world with {}x{} map.",
+                world2.resource::<GameMap>().width,
+                world2.resource::<GameMap>().height
+            );
+        }
+        other => {
+            println!("Unknown codec '{}'", other);
+            println!("Use one of: json|ron|cbor (default json)");
+        }
+    }
     Ok(())
 }
 
diff --git a/crates/gc_core/Cargo.toml b/crates/gc_core/Cargo.toml
index ace6bc1..89627b1 100644
--- a/crates/gc_core/Cargo.toml
+++ b/crates/gc_core/Cargo.toml
@@ -11,6 +11,8 @@ authors = ["Goblin Camp Contributors"]
 bevy_ecs = "0.14"
 serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
+ron = "0.8"
+ciborium = { version = "0.2", features = ["std"] }
 rand = "0.8"
 thiserror = "1.0"
 pathfinding = "4.9.0"
diff --git a/crates/gc_core/src/components.rs b/crates/gc_core/src/components.rs
index d3ce473..a9f5e42 100644
--- a/crates/gc_core/src/components.rs
+++ b/crates/gc_core/src/components.rs
@@ -58,7 +58,7 @@ pub struct DesignationLifecycle(pub DesignationState);
 /// Types of items that can exist in the world
 /// This enum defines all possible item types that can be created,
 /// carried, and stored in stockpiles. Currently only Stone is implemented.
-#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
 pub enum ItemType {
     /// Stone items created from mining operations
     /// These are the primary resource produced by mining wall tiles
diff --git a/crates/gc_core/src/save.rs b/crates/gc_core/src/save.rs
index e56e32b..cb57fd9 100644
--- a/crates/gc_core/src/save.rs
+++ b/crates/gc_core/src/save.rs
@@ -1,7 +1,35 @@
 use crate::components::{Carriable, Item, ItemType};
+use crate::systems;
 use crate::world::{GameMap, Name, Position, TileKind, Velocity};
 use bevy_ecs::prelude::*;
 use serde::{Deserialize, Serialize};
+use std::io::Cursor;
+
+/// Sort entity records in a stable, deterministic order.
+///
+/// Ordering key: (name, pos, vel, item_type, carriable)
+fn sort_entities_deterministically(entities: &mut [EntityData]) {
+    use std::cmp::Ordering;
+    entities.sort_by(|a, b| {
+        let name_ord = a.name.cmp(&b.name);
+        if name_ord != Ordering::Equal {
+            return name_ord;
+        }
+        let pos_ord = a.pos.cmp(&b.pos);
+        if pos_ord != Ordering::Equal {
+            return pos_ord;
+        }
+        let vel_ord = a.vel.cmp(&b.vel);
+        if vel_ord != Ordering::Equal {
+            return vel_ord;
+        }
+        let item_ord = a.item_type.cmp(&b.item_type);
+        if item_ord != Ordering::Equal {
+            return item_ord;
+        }
+        a.carriable.cmp(&b.carriable)
+    });
+}
 
 #[derive(Serialize, Deserialize)]
 pub struct SaveGame {
@@ -9,6 +37,10 @@ pub struct SaveGame {
     pub height: u32,
     pub tiles: Vec<TileKind>,
     pub entities: Vec<EntityData>,
+    // Determinism: persist tick timing and RNG seed (per-stream positions planned)
+    pub tick_ms: u64,
+    pub ticks: u64,
+    pub master_seed: u64,
 }
 
 #[derive(Serialize, Deserialize)]
@@ -44,11 +76,23 @@ pub fn save_world(world: &mut World) -> SaveGame {
             carriable: carriable.is_some(),
         });
     }
+    // Deterministic ordering across codecs and runs
+    sort_entities_deterministically(&mut entities);
+    // Persist determinism metadata
+    let (tick_ms, ticks) = {
+        let time = world.resource::<systems::Time>();
+        (time.tick_ms, time.ticks)
+    };
+    let master_seed = world.resource::<systems::DeterministicRng>().master_seed;
+
     SaveGame {
         width,
         height,
         tiles,
         entities,
+        tick_ms,
+        ticks,
+        master_seed,
     }
 }
 
@@ -58,6 +102,12 @@ pub fn load_world(save: SaveGame, world: &mut World) {
         height: save.height,
         tiles: save.tiles,
     });
+    // Restore deterministic time and RNG seed
+    world.insert_resource(systems::Time {
+        ticks: save.ticks,
+        tick_ms: save.tick_ms,
+    });
+    world.insert_resource(systems::DeterministicRng::new(save.master_seed));
     for e in save.entities {
         let mut ec = world.spawn(());
         if let Some(name) = e.name {
@@ -77,3 +127,38 @@ pub fn load_world(save: SaveGame, world: &mut World) {
         }
     }
 }
+
+// --- Minimal codec helpers (format-agnostic call sites) ---
+
+/// Encode a SaveGame to JSON string
+pub fn encode_json(save: &SaveGame) -> Result<String, serde_json::Error> {
+    serde_json::to_string(save)
+}
+
+/// Decode a SaveGame from JSON string
+pub fn decode_json(s: &str) -> Result<SaveGame, serde_json::Error> {
+    serde_json::from_str(s)
+}
+
+/// Encode a SaveGame to RON string
+pub fn encode_ron(save: &SaveGame) -> Result<String, ron::Error> {
+    ron::ser::to_string(save)
+}
+
+/// Decode a SaveGame from RON string
+pub fn decode_ron(s: &str) -> Result<SaveGame, ron::Error> {
+    ron::de::from_str(s).map_err(ron::Error::from)
+}
+
+/// Encode a SaveGame to CBOR bytes
+pub fn encode_cbor(save: &SaveGame) -> Result<Vec<u8>, ciborium::ser::Error<std::io::Error>> {
+    let mut buf = Vec::new();
+    ciborium::ser::into_writer(save, &mut buf)?;
+    Ok(buf)
+}
+
+/// Decode a SaveGame from CBOR bytes
+pub fn decode_cbor(bytes: &[u8]) -> Result<SaveGame, ciborium::de::Error<std::io::Error>> {
+    let mut cur = Cursor::new(bytes);
+    ciborium::de::from_reader(&mut cur)
+}
diff --git a/crates/gc_core/tests/determinism_tests.rs b/crates/gc_core/tests/determinism_tests.rs
index 1f679ab..6dd806b 100644
--- a/crates/gc_core/tests/determinism_tests.rs
+++ b/crates/gc_core/tests/determinism_tests.rs
@@ -79,6 +79,29 @@ fn deterministic_behavior_across_systems() {
     );
 }
 
+/// Save ordering is stable regardless of entity creation order
+#[test]
+fn deterministic_save_entity_ordering() {
+    let mut world_a = World::new();
+    world_a.insert_resource(GameMap::new(8, 8));
+    // Insert in A order
+    world_a.spawn((Name("B".into()), Position(2, 2)));
+    world_a.spawn((Name("A".into()), Position(1, 1)));
+    let save_a = save_world(&mut world_a);
+
+    let mut world_b = World::new();
+    world_b.insert_resource(GameMap::new(8, 8));
+    // Insert in B order (reverse)
+    world_b.spawn((Name("A".into()), Position(1, 1)));
+    world_b.spawn((Name("B".into()), Position(2, 2)));
+    let save_b = save_world(&mut world_b);
+
+    // JSON bytes should be identical once encoded due to stable ordering
+    let json_a = serde_json::to_string(&save_a).unwrap();
+    let json_b = serde_json::to_string(&save_b).unwrap();
+    assert_eq!(json_a, json_b, "Save ordering should be deterministic");
+}
+
 /// Test that the DeterministicRng resource produces consistent sequences
 #[test]
 fn deterministic_rng_consistent_sequences() {
diff --git a/crates/gc_core/tests/m0_core_tests.rs b/crates/gc_core/tests/m0_core_tests.rs
index e493098..3e342ba 100644
--- a/crates/gc_core/tests/m0_core_tests.rs
+++ b/crates/gc_core/tests/m0_core_tests.rs
@@ -32,6 +32,9 @@ fn save_load_roundtrip() {
 
     let mut w2 = World::new();
     load_world(serde_json::from_str(&json).unwrap(), &mut w2);
+    // Validate time and RNG seed restoration
+    let time = w2.resource::<gc_core::systems::Time>();
+    assert!(time.tick_ms > 0);
     let mut q = w2.query::<(&Name, &Position)>();
     let got: Vec<_> = q.iter(&w2).map(|(n, p)| (n.0.clone(), p.0, p.1)).collect();
     assert_eq!(got.len(), 1);
diff --git a/scripts/create_graphics_epic.sh b/scripts/create_graphics_epic.sh
new file mode 100755
index 0000000..65f983d
--- /dev/null
+++ b/scripts/create_graphics_epic.sh
@@ -0,0 +1,168 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+if ! command -v gh >/dev/null 2>&1; then
+  echo "Error: GitHub CLI 'gh' is not installed. Install from https://cli.github.com and retry." >&2
+  exit 1
+fi
+
+if ! gh auth status >/dev/null 2>&1; then
+  echo "Error: GitHub CLI is not authenticated. Run: gh auth login" >&2
+  exit 1
+fi
+
+EPIC_TITLE="Epic: Graphics UI Alpha (gc_gfx)"
+EPIC_BODY=$(cat <<'EOF'
+Goals:
+- Working, animated, pixel-art tile UI with camera/input.
+- Reuse existing `bevy_ecs` systems deterministically.
+- Keep TUI available.
+
+Non-goals:
+- Full menus, save/load UI, audio, advanced art polish.
+
+Deliverables:
+- `gc_gfx` crate; tilemap + sprites; visibility overlay; mouse designations.
+- Docs: `docs/design/graphics.md`.
+
+Risks:
+- Version mismatches; asset licensing; WSL2 GUI. See epic description for mitigations.
+
+Acceptance:
+- Map + entities render; mining via mouse updates tiles; overlay toggles; 60 FPS on 80x50.
+EOF
+)
+
+# Ensure labels exist
+for L in ui graphics bevy epic core tilemap sprites animation input docs assets licensing ci polish refactor gameplay cli integration; do
+  gh label create "$L" --color "ededed" --description "" >/dev/null 2>&1 || true
+done
+
+# Helper: find first issue URL exactly matching title
+find_issue_url_by_title () {
+  local TITLE="$1"
+  gh issue list --state all --search "$TITLE in:title" --json title,url --jq \
+    ".[] | select(.title==\"$TITLE\") | .url" | head -n 1
+}
+
+# Create epic tracking issue (idempotent)
+EPIC_URL=$(find_issue_url_by_title "$EPIC_TITLE" || true)
+if [[ -z "${EPIC_URL:-}" ]]; then
+  CREATE_OUT=$(gh issue create --title "$EPIC_TITLE" --body "$EPIC_BODY" --label epic --label graphics --label ui --assignee "@me")
+  EPIC_URL=$(echo "$CREATE_OUT" | grep -Eo 'https://github.com/[^ ]+/issues/[0-9]+' | head -n 1)
+  # Fallback: re-query if URL not parsed
+  if [[ -z "${EPIC_URL:-}" ]]; then
+    EPIC_URL=$(find_issue_url_by_title "$EPIC_TITLE")
+  fi
+  echo "Created EPIC: $EPIC_URL"
+else
+  echo "Epic already exists: $EPIC_URL"
+fi
+
+create_issue () {
+  local TITLE="$1"
+  local BODY="$2"
+  local LABELS="$3"
+  local DEPENDS_ON="${4:-}"
+  local URL
+  local LABEL_ARGS=()
+  # Expand comma-separated labels into multiple --label flags
+  IFS=',' read -ra labels_arr <<< "$LABELS"
+  for l in "${labels_arr[@]}"; do LABEL_ARGS+=("--label" "$l"); done
+  if [[ -n "$DEPENDS_ON" ]]; then
+    BODY="$BODY
+
+Depends on: $DEPENDS_ON"
+  fi
+  BODY="$BODY
+
+Parent epic: $EPIC_URL"
+  # Idempotent: check by title first
+  URL=$(find_issue_url_by_title "$TITLE" || true)
+  if [[ -z "${URL:-}" ]]; then
+    CREATE_OUT=$(gh issue create --title "$TITLE" --body "$BODY" "${LABEL_ARGS[@]}" --assignee "@me")
+    URL=$(echo "$CREATE_OUT" | grep -Eo 'https://github.com/[^ ]+/issues/[0-9]+' | head -n 1)
+    if [[ -z "${URL:-}" ]]; then
+      URL=$(find_issue_url_by_title "$TITLE")
+    fi
+  fi
+  echo "$URL"
+}
+
+issue1=$(create_issue "Create Bevy graphics crate gc_gfx and window" "Add new workspace crate; Bevy App; pixel camera; nearest sampling.
+
+AC:
+- cargo run -p gc_gfx opens a window with pixel-perfect camera
+- CI compiles gc_gfx" "ui,graphics,bevy")
+issue2=$(create_issue "Refactor bootstrap to support Bevy App world" "Expose plugin/setup that inserts core resources/entities into Bevy World.
+
+AC:
+- Core runs in Bevy World (no second World)
+- Sim behavior unchanged for N ticks" "core,bevy,refactor" "$issue1")
+issue3=$(create_issue "Integrate core simulation into Bevy schedule" "Register systems/time; maintain determinism.
+
+AC:
+- Pause/step parity with TUI for N steps" "core,bevy" "$issue2")
+issue4=$(create_issue "Add tilemap rendering for GameMap" "Use bevy_ecs_tilemap; TileKind->atlas indices; apply diffs.
+
+AC:
+- Tiles render & update on mining" "graphics,tilemap" "$issue3")
+issue5=$(create_issue "Load and credit a permissive tileset" "Add assets/tiles + attribution.
+
+AC:
+- Assets load; README credits present" "assets,docs,licensing" "$issue1")
+issue6=$(create_issue "Entity sprites for goblins and items" "Sprites for Miner/Carrier/Stone; proper z-order.
+
+AC:
+- Sprites at Position; visible with overlay" "graphics,sprites" "$issue4,$issue5")
+issue7=$(create_issue "Movement tweening and basic sprite animation" "Tween between tiles; walk cycle frames.
+
+AC:
+- Smooth movement; idle vs walk frames" "graphics,animation" "$issue6")
+issue8=$(create_issue "Camera controls and UI overlay" "WASD/arrow pan, +/- zoom; HUD text for paused/steps.
+
+AC:
+- Input works; HUD reflects state" "ui,input" "$issue3")
+issue9=$(create_issue "Visibility overlay layer" "Semi-transparent tile overlay from FOV.
+
+AC:
+- Toggleable overlay without perf regressions" "graphics" "$issue4,$issue8")
+issue10=$(create_issue "Mouse mining designations" "Click-drag rectangle spawns MineDesignation.
+
+AC:
+- Mining changes tiles and drops items" "input,ui,gameplay" "$issue3,$issue4,$issue8")
+issue11=$(create_issue "CLI integration: add gfx demo route" "Add 'gfx' subcommand to launch gc_gfx.
+
+AC:
+- goblin-camp gfx launches Bevy UI" "cli,integration" "$issue1")
+issue12=$(create_issue "Docs: graphics design + runbook" "Design doc, assets license notes, WSL/GL troubleshooting.
+
+AC:
+- Clear run instructions and credits" "docs" "$issue5")
+issue13=$(create_issue "CI build of gc_gfx" "Compile-only CI job for gc_gfx.
+
+AC:
+- CI passes on Linux" "ci" "$issue1")
+issue14=$(create_issue "Polish: water/lava tile animation + particles (optional)" "Animate water/lava; simple mining particles.
+
+AC:
+- Visible animated tiles + effect" "graphics,polish" "$issue7,$issue9")
+
+echo "Created issues:"
+echo "$issue1"
+echo "$issue2"
+echo "$issue3"
+echo "$issue4"
+echo "$issue5"
+echo "$issue6"
+echo "$issue7"
+echo "$issue8"
+echo "$issue9"
+echo "$issue10"
+echo "$issue11"
+echo "$issue12"
+echo "$issue13"
+echo "$issue14"
+echo "All issues reference EPIC: $EPIC_URL"
+
+
diff --git a/scripts/normalize_graphics_issues.sh b/scripts/normalize_graphics_issues.sh
new file mode 100755
index 0000000..2283057
--- /dev/null
+++ b/scripts/normalize_graphics_issues.sh
@@ -0,0 +1,58 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+if ! command -v gh >/dev/null 2>&1; then
+  echo "Error: GitHub CLI 'gh' is not installed." >&2
+  exit 1
+fi
+
+EPIC_URL=${EPIC_URL:-"https://github.com/acaradonna/goblin-camp/issues/181"}
+
+declare -A issue_labels
+issue_labels[182]="ui,graphics,bevy"
+issue_labels[193]="core,bevy,refactor"
+issue_labels[183]="core,bevy"
+issue_labels[184]="graphics,tilemap"
+issue_labels[185]="assets,docs,licensing"
+issue_labels[186]="graphics,sprites"
+issue_labels[187]="graphics,animation"
+issue_labels[188]="ui,input"
+issue_labels[189]="graphics"
+issue_labels[194]="input,ui,gameplay"
+issue_labels[195]="cli,integration"
+issue_labels[190]="docs"
+issue_labels[191]="ci"
+issue_labels[192]="graphics,polish"
+
+issue_ids=(182 183 184 185 186 187 188 189 190 191 192 193 194 195)
+
+for id in "${issue_ids[@]}"; do
+  echo "Normalizing #$id"
+  title=$(gh issue view "$id" --json title --jq .title)
+  labels_expected_csv=${issue_labels[$id]:-}
+  # Add missing labels only
+  if [[ -n "$labels_expected_csv" ]]; then
+    IFS=',' read -ra expected <<< "$labels_expected_csv"
+    for lbl in "${expected[@]}"; do
+      # If label is already present, skip
+      if gh issue view "$id" --json labels --jq '.labels[].name' | grep -Fxq "$lbl"; then
+        :
+      else
+        gh issue edit "$id" --add-label "$lbl" >/dev/null
+      fi
+    done
+  fi
+
+  # Ensure Parent epic line exists in body
+  body=$(gh issue view "$id" --json body --jq .body)
+  if ! printf "%s" "$body" | grep -Fq "Parent epic:"; then
+    tmp=$(mktemp)
+    printf "%s\n\nParent epic: %s\n" "$body" "$EPIC_URL" > "$tmp"
+    gh issue edit "$id" --body-file "$tmp" >/dev/null
+    rm -f "$tmp"
+  fi
+done
+
+echo "Done."
+
+
