[
  {
    "sha": "acd9cd5f0592112f6297081951dd9daa005e8667",
    "filename": "crates/gc_core/resources/recipes.json",
    "status": "added",
    "additions": 18,
    "deletions": 0,
    "changes": 18,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fresources%2Frecipes.json",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fresources%2Frecipes.json",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fresources%2Frecipes.json?ref=7121f94d2fb402dc29a89181d20252e87a216a6c",
    "patch": "@@ -0,0 +1,18 @@\n+{\n+  \"recipes\": [\n+    {\n+      \"id\": \"logs_to_planks\",\n+      \"stations\": [\"carpenter\"],\n+      \"inputs\": [{ \"item\": \"Log\", \"count\": 1 }],\n+      \"outputs\": [{ \"item\": \"Plank\", \"count\": 4 }],\n+      \"work_time_ticks\": 50\n+    },\n+    {\n+      \"id\": \"stone_to_blocks\",\n+      \"stations\": [\"mason\"],\n+      \"inputs\": [{ \"item\": \"Stone\", \"count\": 1 }],\n+      \"outputs\": [{ \"item\": \"Block\", \"count\": 1 }],\n+      \"work_time_ticks\": 50\n+    }\n+  ]\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "3e54bc7ff36f843b5e8627faf76e9b994ff522eb",
    "filename": "crates/gc_core/src/bootstrap.rs",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Fbootstrap.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Fbootstrap.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fbootstrap.rs?ref=7121f94d2fb402dc29a89181d20252e87a216a6c",
    "patch": "@@ -53,6 +53,11 @@ pub fn build_standard_world(width: u32, height: u32, seed: u64, opts: WorldOptio\n     world.insert_resource(designations::DesignationConfig { auto_jobs: true });\n     world.insert_resource(systems::Time::new(opts.tick_ms));\n \n+    // Load recipe registry with default recipes\n+    let recipe_registry = crate::recipes::RecipeRegistry::load_default()\n+        .expect(\"Failed to load default recipe registry\");\n+    world.insert_resource(recipe_registry);\n+\n     if opts.populate_demo_scene {\n         // Miner\n         world.spawn(("
  },
  {
    "sha": "f2b84a981094a8e92f22f975f6d3f819db3afc6f",
    "filename": "crates/gc_core/src/components.rs",
    "status": "modified",
    "additions": 10,
    "deletions": 1,
    "changes": 11,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Fcomponents.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Fcomponents.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fcomponents.rs?ref=7121f94d2fb402dc29a89181d20252e87a216a6c",
    "patch": "@@ -62,12 +62,21 @@ pub struct DesignationLifecycle(pub DesignationState);\n \n /// Types of items that can exist in the world\n /// This enum defines all possible item types that can be created,\n-/// carried, and stored in stockpiles. Currently only Stone is implemented.\n+/// carried, and stored in stockpiles.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n pub enum ItemType {\n     /// Stone items created from mining operations\n     /// These are the primary resource produced by mining wall tiles\n     Stone,\n+    /// Log items for construction and crafting\n+    /// Raw wood material harvested from trees\n+    Log,\n+    /// Plank items crafted from logs\n+    /// Processed wood for construction and furniture\n+    Plank,\n+    /// Block items crafted from stone\n+    /// Processed stone for construction\n+    Block,\n }\n \n /// Component representing an item entity that can be spawned, carried, and placed"
  },
  {
    "sha": "c722426460e8caae256db4e4291c837e2ecd1024",
    "filename": "crates/gc_core/src/jobs.rs",
    "status": "modified",
    "additions": 33,
    "deletions": 0,
    "changes": 33,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Fjobs.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Fjobs.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fjobs.rs?ref=7121f94d2fb402dc29a89181d20252e87a216a6c",
    "patch": "@@ -203,6 +203,39 @@ pub fn process_item_spawn_queue_system(\n                     crate::world::Name(\"Stone\".to_string()),\n                 ));\n             }\n+            ItemType::Log => {\n+                // Create a log item entity\n+                commands.spawn((\n+                    Item {\n+                        item_type: ItemType::Log,\n+                    },\n+                    crate::world::Position(x, y),\n+                    crate::components::Carriable,\n+                    crate::world::Name(\"Log\".to_string()),\n+                ));\n+            }\n+            ItemType::Plank => {\n+                // Create a plank item entity\n+                commands.spawn((\n+                    Item {\n+                        item_type: ItemType::Plank,\n+                    },\n+                    crate::world::Position(x, y),\n+                    crate::components::Carriable,\n+                    crate::world::Name(\"Plank\".to_string()),\n+                ));\n+            }\n+            ItemType::Block => {\n+                // Create a block item entity\n+                commands.spawn((\n+                    Item {\n+                        item_type: ItemType::Block,\n+                    },\n+                    crate::world::Position(x, y),\n+                    crate::components::Carriable,\n+                    crate::world::Name(\"Block\".to_string()),\n+                ));\n+            }\n         }\n     }\n }"
  },
  {
    "sha": "600e89187ae6a00477dbabcd349fe05349147c4c",
    "filename": "crates/gc_core/src/lib.rs",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Flib.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Flib.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Flib.rs?ref=7121f94d2fb402dc29a89181d20252e87a216a6c",
    "patch": "@@ -111,6 +111,7 @@ pub mod prelude {\n     pub use crate::jobs::*;\n     pub use crate::mapgen::*;\n     pub use crate::path::*;\n+    pub use crate::recipes::*;\n     pub use crate::save::*;\n     pub use crate::stockpiles::*;\n     pub use crate::systems::*;\n@@ -135,6 +136,8 @@ pub mod jobs;\n pub mod mapgen;\n /// A* pathfinding with caching and optimization\n pub mod path;\n+/// Recipe registry and crafting system for workshops\n+pub mod recipes;\n /// World serialization and save/load functionality\n pub mod save;\n /// Storage zones and item organization systems"
  },
  {
    "sha": "4e7891b6ce318ed20256837ec2ce3647b851e1d0",
    "filename": "crates/gc_core/src/recipes.rs",
    "status": "added",
    "additions": 510,
    "deletions": 0,
    "changes": 510,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Frecipes.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Fsrc%2Frecipes.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Frecipes.rs?ref=7121f94d2fb402dc29a89181d20252e87a216a6c",
    "patch": "@@ -0,0 +1,510 @@\n+/// Recipe registry and crafting system for workshops\n+///\n+/// This module defines the core types and functionality for the recipe system,\n+/// which manages crafting recipes, ingredient specifications, and production chains.\n+/// Recipes define how raw materials are transformed into finished goods through\n+/// various workshop stations.\n+use crate::components::ItemType;\n+use bevy_ecs::prelude::*;\n+use serde::{Deserialize, Serialize};\n+use std::collections::HashMap;\n+\n+/// Specifies an ingredient required for a recipe\n+/// Defines both the type of item needed and the quantity required\n+#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n+pub struct IngredientSpec {\n+    /// The type of item required as an ingredient\n+    pub item: ItemType,\n+    /// The number of items required\n+    pub count: u32,\n+}\n+\n+impl IngredientSpec {\n+    /// Create a new ingredient specification\n+    pub fn new(item: ItemType, count: u32) -> Self {\n+        Self { item, count }\n+    }\n+}\n+\n+/// Specifies a product produced by a recipe\n+/// Defines both the type of item produced and the quantity created\n+#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n+pub struct ProductSpec {\n+    /// The type of item produced\n+    pub item: ItemType,\n+    /// The number of items produced\n+    pub count: u32,\n+    /// Whether this is a byproduct (true) or main product (false)\n+    /// Byproducts may have different handling rules in the future\n+    #[serde(default)]\n+    pub byproduct: bool,\n+}\n+\n+impl ProductSpec {\n+    /// Create a new product specification\n+    pub fn new(item: ItemType, count: u32) -> Self {\n+        Self {\n+            item,\n+            count,\n+            byproduct: false,\n+        }\n+    }\n+\n+    /// Create a new byproduct specification\n+    pub fn new_byproduct(item: ItemType, count: u32) -> Self {\n+        Self {\n+            item,\n+            count,\n+            byproduct: true,\n+        }\n+    }\n+}\n+\n+/// A complete recipe definition for crafting operations\n+/// Recipes define the transformation of input ingredients into output products\n+/// through specific workshop stations over a defined time period\n+#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n+pub struct Recipe {\n+    /// Unique identifier for this recipe\n+    pub id: String,\n+    /// List of workshop station types that can execute this recipe\n+    pub stations: Vec<String>,\n+    /// List of required ingredients with quantities\n+    pub inputs: Vec<IngredientSpec>,\n+    /// List of produced items with quantities\n+    pub outputs: Vec<ProductSpec>,\n+    /// Time required to complete the recipe in simulation ticks\n+    pub work_time_ticks: u32,\n+}\n+\n+impl Recipe {\n+    /// Create a new recipe\n+    pub fn new(\n+        id: String,\n+        stations: Vec<String>,\n+        inputs: Vec<IngredientSpec>,\n+        outputs: Vec<ProductSpec>,\n+        work_time_ticks: u32,\n+    ) -> Self {\n+        Self {\n+            id,\n+            stations,\n+            inputs,\n+            outputs,\n+            work_time_ticks,\n+        }\n+    }\n+\n+    /// Validate the recipe for basic consistency\n+    /// Returns true if the recipe is valid, false otherwise\n+    pub fn validate(&self) -> bool {\n+        // Recipe must have an ID\n+        if self.id.is_empty() {\n+            return false;\n+        }\n+\n+        // Recipe must have at least one station\n+        if self.stations.is_empty() {\n+            return false;\n+        }\n+\n+        // Recipe must have at least one input\n+        if self.inputs.is_empty() {\n+            return false;\n+        }\n+\n+        // Recipe must have at least one output\n+        if self.outputs.is_empty() {\n+            return false;\n+        }\n+\n+        // All ingredient counts must be positive\n+        if self.inputs.iter().any(|spec| spec.count == 0) {\n+            return false;\n+        }\n+\n+        // All product counts must be positive\n+        if self.outputs.iter().any(|spec| spec.count == 0) {\n+            return false;\n+        }\n+\n+        // Work time must be positive\n+        if self.work_time_ticks == 0 {\n+            return false;\n+        }\n+\n+        true\n+    }\n+}\n+\n+/// Error types for recipe registry operations\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum RecipeRegistryError {\n+    /// Recipe with duplicate ID was found\n+    DuplicateRecipeId(String),\n+    /// Recipe failed validation\n+    InvalidRecipe(String),\n+    /// JSON parsing failed\n+    ParseError(String),\n+    /// Unknown item type was referenced\n+    UnknownItemType(String),\n+}\n+\n+impl std::fmt::Display for RecipeRegistryError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            RecipeRegistryError::DuplicateRecipeId(id) => write!(f, \"Duplicate recipe ID: {}\", id),\n+            RecipeRegistryError::InvalidRecipe(id) => write!(f, \"Invalid recipe: {}\", id),\n+            RecipeRegistryError::ParseError(msg) => write!(f, \"Parse error: {}\", msg),\n+            RecipeRegistryError::UnknownItemType(item) => write!(f, \"Unknown item type: {}\", item),\n+        }\n+    }\n+}\n+\n+impl std::error::Error for RecipeRegistryError {}\n+\n+/// Registry containing all available crafting recipes\n+/// This is the central repository for recipe data that gets loaded at startup\n+/// and used throughout the simulation for crafting operations\n+#[derive(Debug, Clone, Resource)]\n+pub struct RecipeRegistry {\n+    /// Map of recipe ID to recipe data\n+    recipes: HashMap<String, Recipe>,\n+}\n+\n+impl RecipeRegistry {\n+    /// Create a new empty recipe registry\n+    pub fn new() -> Self {\n+        Self {\n+            recipes: HashMap::new(),\n+        }\n+    }\n+\n+    /// Create a recipe registry from JSON data\n+    /// Validates all recipes and ensures no duplicate IDs\n+    pub fn from_json(json_data: &str) -> Result<Self, RecipeRegistryError> {\n+        // Parse the JSON structure\n+        let parsed: serde_json::Value = serde_json::from_str(json_data)\n+            .map_err(|e| RecipeRegistryError::ParseError(e.to_string()))?;\n+\n+        // Extract the recipes array\n+        let recipes_array = parsed\n+            .get(\"recipes\")\n+            .and_then(|v| v.as_array())\n+            .ok_or_else(|| {\n+                RecipeRegistryError::ParseError(\"Missing 'recipes' array\".to_string())\n+            })?;\n+\n+        let mut registry = Self::new();\n+\n+        // Parse each recipe\n+        for recipe_value in recipes_array {\n+            let recipe: Recipe = serde_json::from_value(recipe_value.clone())\n+                .map_err(|e| RecipeRegistryError::ParseError(e.to_string()))?;\n+\n+            // Validate the recipe\n+            if !recipe.validate() {\n+                return Err(RecipeRegistryError::InvalidRecipe(recipe.id));\n+            }\n+\n+            // Check for duplicate IDs\n+            if registry.recipes.contains_key(&recipe.id) {\n+                return Err(RecipeRegistryError::DuplicateRecipeId(recipe.id));\n+            }\n+\n+            registry.recipes.insert(recipe.id.clone(), recipe);\n+        }\n+\n+        Ok(registry)\n+    }\n+\n+    /// Load the default embedded recipe registry\n+    /// This provides the example recipes specified in the requirements\n+    pub fn load_default() -> Result<Self, RecipeRegistryError> {\n+        const DEFAULT_RECIPES_JSON: &str = include_str!(\"../resources/recipes.json\");\n+        Self::from_json(DEFAULT_RECIPES_JSON)\n+    }\n+\n+    /// Get a recipe by ID\n+    pub fn get_recipe(&self, id: &str) -> Option<&Recipe> {\n+        self.recipes.get(id)\n+    }\n+\n+    /// Get all recipe IDs\n+    pub fn recipe_ids(&self) -> impl Iterator<Item = &String> {\n+        self.recipes.keys()\n+    }\n+\n+    /// Get all recipes\n+    pub fn recipes(&self) -> impl Iterator<Item = &Recipe> {\n+        self.recipes.values()\n+    }\n+\n+    /// Get the number of recipes in the registry\n+    pub fn len(&self) -> usize {\n+        self.recipes.len()\n+    }\n+\n+    /// Check if the registry is empty\n+    pub fn is_empty(&self) -> bool {\n+        self.recipes.is_empty()\n+    }\n+\n+    /// Find recipes that can be performed at a specific station type\n+    pub fn recipes_for_station<'a>(\n+        &'a self,\n+        station_type: &str,\n+    ) -> impl Iterator<Item = &'a Recipe> + 'a {\n+        let station_type_owned = station_type.to_string();\n+        self.recipes\n+            .values()\n+            .filter(move |recipe| recipe.stations.contains(&station_type_owned))\n+    }\n+}\n+\n+impl Default for RecipeRegistry {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn ingredient_spec_creation() {\n+        let spec = IngredientSpec::new(ItemType::Stone, 5);\n+        assert_eq!(spec.item, ItemType::Stone);\n+        assert_eq!(spec.count, 5);\n+    }\n+\n+    #[test]\n+    fn product_spec_creation() {\n+        let spec = ProductSpec::new(ItemType::Block, 3);\n+        assert_eq!(spec.item, ItemType::Block);\n+        assert_eq!(spec.count, 3);\n+        assert!(!spec.byproduct);\n+\n+        let byproduct = ProductSpec::new_byproduct(ItemType::Stone, 1);\n+        assert!(byproduct.byproduct);\n+    }\n+\n+    #[test]\n+    fn recipe_validation_success() {\n+        let recipe = Recipe::new(\n+            \"test_recipe\".to_string(),\n+            vec![\"workshop\".to_string()],\n+            vec![IngredientSpec::new(ItemType::Log, 1)],\n+            vec![ProductSpec::new(ItemType::Plank, 4)],\n+            50,\n+        );\n+\n+        assert!(recipe.validate());\n+    }\n+\n+    #[test]\n+    fn recipe_validation_empty_id() {\n+        let recipe = Recipe::new(\n+            \"\".to_string(),\n+            vec![\"workshop\".to_string()],\n+            vec![IngredientSpec::new(ItemType::Log, 1)],\n+            vec![ProductSpec::new(ItemType::Plank, 4)],\n+            50,\n+        );\n+\n+        assert!(!recipe.validate());\n+    }\n+\n+    #[test]\n+    fn recipe_validation_zero_count() {\n+        let recipe = Recipe::new(\n+            \"test_recipe\".to_string(),\n+            vec![\"workshop\".to_string()],\n+            vec![IngredientSpec::new(ItemType::Log, 0)], // Zero count\n+            vec![ProductSpec::new(ItemType::Plank, 4)],\n+            50,\n+        );\n+\n+        assert!(!recipe.validate());\n+    }\n+\n+    #[test]\n+    fn recipe_validation_zero_work_time() {\n+        let recipe = Recipe::new(\n+            \"test_recipe\".to_string(),\n+            vec![\"workshop\".to_string()],\n+            vec![IngredientSpec::new(ItemType::Log, 1)],\n+            vec![ProductSpec::new(ItemType::Plank, 4)],\n+            0, // Zero work time\n+        );\n+\n+        assert!(!recipe.validate());\n+    }\n+\n+    #[test]\n+    fn recipe_registry_creation() {\n+        let registry = RecipeRegistry::new();\n+        assert!(registry.is_empty());\n+        assert_eq!(registry.len(), 0);\n+    }\n+\n+    #[test]\n+    fn parse_valid_json() {\n+        let json = r#\"\n+        {\n+          \"recipes\": [\n+            {\n+              \"id\": \"logs_to_planks\",\n+              \"stations\": [\"carpenter\"],\n+              \"inputs\": [{ \"item\": \"Log\", \"count\": 1 }],\n+              \"outputs\": [{ \"item\": \"Plank\", \"count\": 4 }],\n+              \"work_time_ticks\": 50\n+            }\n+          ]\n+        }\n+        \"#;\n+\n+        let registry = RecipeRegistry::from_json(json).expect(\"Should parse valid JSON\");\n+        assert_eq!(registry.len(), 1);\n+\n+        let recipe = registry\n+            .get_recipe(\"logs_to_planks\")\n+            .expect(\"Should have recipe\");\n+        assert_eq!(recipe.id, \"logs_to_planks\");\n+        assert_eq!(recipe.stations, vec![\"carpenter\"]);\n+        assert_eq!(recipe.inputs.len(), 1);\n+        assert_eq!(recipe.inputs[0].item, ItemType::Log);\n+        assert_eq!(recipe.inputs[0].count, 1);\n+        assert_eq!(recipe.outputs.len(), 1);\n+        assert_eq!(recipe.outputs[0].item, ItemType::Plank);\n+        assert_eq!(recipe.outputs[0].count, 4);\n+        assert_eq!(recipe.work_time_ticks, 50);\n+    }\n+\n+    #[test]\n+    fn reject_duplicate_recipe_ids() {\n+        let json = r#\"\n+        {\n+          \"recipes\": [\n+            {\n+              \"id\": \"duplicate\",\n+              \"stations\": [\"carpenter\"],\n+              \"inputs\": [{ \"item\": \"Log\", \"count\": 1 }],\n+              \"outputs\": [{ \"item\": \"Plank\", \"count\": 4 }],\n+              \"work_time_ticks\": 50\n+            },\n+            {\n+              \"id\": \"duplicate\",\n+              \"stations\": [\"mason\"],\n+              \"inputs\": [{ \"item\": \"Stone\", \"count\": 1 }],\n+              \"outputs\": [{ \"item\": \"Block\", \"count\": 1 }],\n+              \"work_time_ticks\": 30\n+            }\n+          ]\n+        }\n+        \"#;\n+\n+        let result = RecipeRegistry::from_json(json);\n+        assert!(matches!(\n+            result,\n+            Err(RecipeRegistryError::DuplicateRecipeId(_))\n+        ));\n+    }\n+\n+    #[test]\n+    fn reject_invalid_recipe() {\n+        let json = r#\"\n+        {\n+          \"recipes\": [\n+            {\n+              \"id\": \"invalid\",\n+              \"stations\": [\"carpenter\"],\n+              \"inputs\": [{ \"item\": \"Log\", \"count\": 0 }],\n+              \"outputs\": [{ \"item\": \"Plank\", \"count\": 4 }],\n+              \"work_time_ticks\": 50\n+            }\n+          ]\n+        }\n+        \"#;\n+\n+        let result = RecipeRegistry::from_json(json);\n+        assert!(matches!(result, Err(RecipeRegistryError::InvalidRecipe(_))));\n+    }\n+\n+    #[test]\n+    fn recipes_for_station_filtering() {\n+        let json = r#\"\n+        {\n+          \"recipes\": [\n+            {\n+              \"id\": \"logs_to_planks\",\n+              \"stations\": [\"carpenter\"],\n+              \"inputs\": [{ \"item\": \"Log\", \"count\": 1 }],\n+              \"outputs\": [{ \"item\": \"Plank\", \"count\": 4 }],\n+              \"work_time_ticks\": 50\n+            },\n+            {\n+              \"id\": \"stone_to_blocks\",\n+              \"stations\": [\"mason\"],\n+              \"inputs\": [{ \"item\": \"Stone\", \"count\": 1 }],\n+              \"outputs\": [{ \"item\": \"Block\", \"count\": 1 }],\n+              \"work_time_ticks\": 50\n+            },\n+            {\n+              \"id\": \"multi_station\",\n+              \"stations\": [\"carpenter\", \"mason\"],\n+              \"inputs\": [{ \"item\": \"Log\", \"count\": 1 }],\n+              \"outputs\": [{ \"item\": \"Block\", \"count\": 1 }],\n+              \"work_time_ticks\": 100\n+            }\n+          ]\n+        }\n+        \"#;\n+\n+        let registry = RecipeRegistry::from_json(json).expect(\"Should parse\");\n+\n+        let carpenter_recipes: Vec<_> = registry.recipes_for_station(\"carpenter\").collect();\n+        assert_eq!(carpenter_recipes.len(), 2);\n+\n+        let mason_recipes: Vec<_> = registry.recipes_for_station(\"mason\").collect();\n+        assert_eq!(mason_recipes.len(), 2);\n+\n+        let nonexistent_recipes: Vec<_> = registry.recipes_for_station(\"blacksmith\").collect();\n+        assert_eq!(nonexistent_recipes.len(), 0);\n+    }\n+\n+    #[test]\n+    fn load_default_registry() {\n+        let registry = RecipeRegistry::load_default().expect(\"Should load default registry\");\n+\n+        // Should have the two example recipes\n+        assert_eq!(registry.len(), 2);\n+\n+        // Verify logs_to_planks recipe\n+        let logs_recipe = registry\n+            .get_recipe(\"logs_to_planks\")\n+            .expect(\"Should have logs_to_planks\");\n+        assert_eq!(logs_recipe.stations, vec![\"carpenter\"]);\n+        assert_eq!(logs_recipe.inputs.len(), 1);\n+        assert_eq!(logs_recipe.inputs[0].item, ItemType::Log);\n+        assert_eq!(logs_recipe.inputs[0].count, 1);\n+        assert_eq!(logs_recipe.outputs.len(), 1);\n+        assert_eq!(logs_recipe.outputs[0].item, ItemType::Plank);\n+        assert_eq!(logs_recipe.outputs[0].count, 4);\n+        assert_eq!(logs_recipe.work_time_ticks, 50);\n+\n+        // Verify stone_to_blocks recipe\n+        let stone_recipe = registry\n+            .get_recipe(\"stone_to_blocks\")\n+            .expect(\"Should have stone_to_blocks\");\n+        assert_eq!(stone_recipe.stations, vec![\"mason\"]);\n+        assert_eq!(stone_recipe.inputs.len(), 1);\n+        assert_eq!(stone_recipe.inputs[0].item, ItemType::Stone);\n+        assert_eq!(stone_recipe.inputs[0].count, 1);\n+        assert_eq!(stone_recipe.outputs.len(), 1);\n+        assert_eq!(stone_recipe.outputs[0].item, ItemType::Block);\n+        assert_eq!(stone_recipe.outputs[0].count, 1);\n+        assert_eq!(stone_recipe.work_time_ticks, 50);\n+    }\n+}"
  },
  {
    "sha": "95f2a47d52d515786d4d65b47757c31304bb9e0a",
    "filename": "crates/gc_core/tests/recipe_registry_tests.rs",
    "status": "added",
    "additions": 103,
    "deletions": 0,
    "changes": 103,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Ftests%2Frecipe_registry_tests.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/7121f94d2fb402dc29a89181d20252e87a216a6c/crates%2Fgc_core%2Ftests%2Frecipe_registry_tests.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Ftests%2Frecipe_registry_tests.rs?ref=7121f94d2fb402dc29a89181d20252e87a216a6c",
    "patch": "@@ -0,0 +1,103 @@\n+/// Integration tests for recipe registry system\n+/// Tests that the recipe registry is properly integrated into the ECS world\n+use gc_core::prelude::*;\n+\n+#[test]\n+fn recipe_registry_available_in_standard_world() {\n+    let world = build_standard_world(20, 20, 42, WorldOptions::default());\n+\n+    // Recipe registry should be available as a resource\n+    let registry = world.resource::<RecipeRegistry>();\n+\n+    // Should contain the default recipes\n+    assert_eq!(registry.len(), 2);\n+    assert!(registry.get_recipe(\"logs_to_planks\").is_some());\n+    assert!(registry.get_recipe(\"stone_to_blocks\").is_some());\n+}\n+\n+#[test]\n+fn recipe_registry_validation_during_world_build() {\n+    // Should not panic during world creation even with complex recipes\n+    let _world = build_standard_world(\n+        50,\n+        50,\n+        123,\n+        WorldOptions {\n+            populate_demo_scene: true,\n+            tick_ms: 100,\n+        },\n+    );\n+    // If we get here without panicking, the registry loaded successfully\n+}\n+\n+#[test]\n+fn recipe_registry_resource_usage() {\n+    let world = build_standard_world(10, 10, 42, WorldOptions::default());\n+\n+    // Should be able to query recipes from within a system context\n+    let registry = world.resource::<RecipeRegistry>();\n+\n+    // Test station filtering functionality\n+    let carpenter_recipes: Vec<_> = registry.recipes_for_station(\"carpenter\").collect();\n+    assert_eq!(carpenter_recipes.len(), 1);\n+    assert_eq!(carpenter_recipes[0].id, \"logs_to_planks\");\n+\n+    let mason_recipes: Vec<_> = registry.recipes_for_station(\"mason\").collect();\n+    assert_eq!(mason_recipes.len(), 1);\n+    assert_eq!(mason_recipes[0].id, \"stone_to_blocks\");\n+}\n+\n+#[test]\n+fn recipe_ingredients_and_products_valid() {\n+    let world = build_standard_world(10, 10, 42, WorldOptions::default());\n+    let registry = world.resource::<RecipeRegistry>();\n+\n+    // Verify logs_to_planks recipe structure\n+    let recipe = registry.get_recipe(\"logs_to_planks\").unwrap();\n+    assert_eq!(recipe.inputs.len(), 1);\n+    assert_eq!(recipe.inputs[0].item, ItemType::Log);\n+    assert_eq!(recipe.inputs[0].count, 1);\n+\n+    assert_eq!(recipe.outputs.len(), 1);\n+    assert_eq!(recipe.outputs[0].item, ItemType::Plank);\n+    assert_eq!(recipe.outputs[0].count, 4);\n+    assert!(!recipe.outputs[0].byproduct);\n+\n+    // Verify stone_to_blocks recipe structure\n+    let recipe = registry.get_recipe(\"stone_to_blocks\").unwrap();\n+    assert_eq!(recipe.inputs.len(), 1);\n+    assert_eq!(recipe.inputs[0].item, ItemType::Stone);\n+    assert_eq!(recipe.inputs[0].count, 1);\n+\n+    assert_eq!(recipe.outputs.len(), 1);\n+    assert_eq!(recipe.outputs[0].item, ItemType::Block);\n+    assert_eq!(recipe.outputs[0].count, 1);\n+    assert!(!recipe.outputs[0].byproduct);\n+}\n+\n+#[test]\n+fn recipe_validation_all_items_known() {\n+    let world = build_standard_world(10, 10, 42, WorldOptions::default());\n+    let registry = world.resource::<RecipeRegistry>();\n+\n+    // All item types in recipes should be valid ItemType variants\n+    for recipe in registry.recipes() {\n+        for input in &recipe.inputs {\n+            // These should all be valid ItemType variants\n+            match input.item {\n+                ItemType::Stone | ItemType::Log | ItemType::Plank | ItemType::Block => {\n+                    // If new item types are added, they should be handled\n+                }\n+            }\n+        }\n+\n+        for output in &recipe.outputs {\n+            match output.item {\n+                ItemType::Stone | ItemType::Log | ItemType::Plank | ItemType::Block => {}\n+            }\n+        }\n+\n+        // All recipes should be valid\n+        assert!(recipe.validate());\n+    }\n+}"
  }
]
