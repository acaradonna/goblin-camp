[
  {
    "sha": "18d9b62e97b44027fb0f0db0f93a18d122f30e3a",
    "filename": "Cargo.lock",
    "status": "modified",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/Cargo.lock",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/Cargo.lock",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/Cargo.lock?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -118,6 +118,12 @@ version = \"1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8\"\n \n+[[package]]\n+name = \"base64\"\n+version = \"0.21.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567\"\n+\n [[package]]\n name = \"bevy_ecs\"\n version = \"0.14.2\"\n@@ -238,6 +244,9 @@ name = \"bitflags\"\n version = \"2.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"34efbcccd345379ca2868b2b2c9d3782e9cc58ba87bc7d79d5b53d9c9ae6f25d\"\n+dependencies = [\n+ \"serde\",\n+]\n \n [[package]]\n name = \"bumpalo\"\n@@ -593,11 +602,13 @@ name = \"gc_core\"\n version = \"0.1.0\"\n dependencies = [\n  \"bevy_ecs\",\n+ \"ciborium\",\n  \"criterion\",\n  \"lru\",\n  \"noise\",\n  \"pathfinding\",\n  \"rand\",\n+ \"ron\",\n  \"serde\",\n  \"serde_json\",\n  \"thiserror 1.0.69\",\n@@ -1110,6 +1121,18 @@ version = \"0.8.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001\"\n \n+[[package]]\n+name = \"ron\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b91f7eff05f748767f183df4320a63d6936e9c6107d97c9e6bdd9784f4289c94\"\n+dependencies = [\n+ \"base64\",\n+ \"bitflags\",\n+ \"serde\",\n+ \"serde_derive\",\n+]\n+\n [[package]]\n name = \"rustc-hash\"\n version = \"2.1.1\""
  },
  {
    "sha": "cd0219d07818c9071bd2ebff5d35e65cc0637865",
    "filename": "crates/gc_cli/src/main.rs",
    "status": "modified",
    "additions": 47,
    "deletions": 10,
    "changes": 57,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_cli%2Fsrc%2Fmain.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_cli%2Fsrc%2Fmain.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_cli%2Fsrc%2Fmain.rs?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -50,6 +50,10 @@ struct Args {\n     #[arg(long, default_value_t = false)]\n     show_vis: bool,\n \n+    /// Codec for save/load demo: json|ron|cbor (default: json)\n+    #[arg(long, default_value = \"json\")]\n+    codec: String,\n+\n     /// Choose a demo to run. If omitted or set to `menu`, an interactive picker is shown.\n     #[command(subcommand)]\n     demo: Option<Demo>,\n@@ -330,16 +334,49 @@ fn run_demo_jobs(args: &Args) -> Result<()> {\n fn run_demo_save(args: &Args) -> Result<()> {\n     let mut world = build_world(args);\n     let save = save_world(&mut world);\n-    let json = serde_json::to_string(&save)?;\n-    println!(\"Serialized save length: {} bytes\", json.len());\n-    let parsed: save::SaveGame = serde_json::from_str(&json)?;\n-    let mut world2 = World::new();\n-    load_world(parsed, &mut world2);\n-    println!(\n-        \"Reloaded world with {}x{} map.\",\n-        world2.resource::<GameMap>().width,\n-        world2.resource::<GameMap>().height\n-    );\n+    match args.codec.as_str() {\n+        \"json\" => {\n+            let data = save::encode_json(&save)?;\n+            println!(\"Serialized (json) length: {} bytes\", data.len());\n+            let parsed: save::SaveGame = save::decode_json(&data)?;\n+            let mut world2 = World::new();\n+            load_world(parsed, &mut world2);\n+            println!(\n+                \"Reloaded world with {}x{} map.\",\n+                world2.resource::<GameMap>().width,\n+                world2.resource::<GameMap>().height\n+            );\n+        }\n+        \"ron\" => {\n+            let data = save::encode_ron(&save).map_err(|e| anyhow::anyhow!(e))?;\n+            println!(\"Serialized (ron) length: {} bytes\", data.len());\n+            let parsed: save::SaveGame = save::decode_ron(&data).map_err(|e| anyhow::anyhow!(e))?;\n+            let mut world2 = World::new();\n+            load_world(parsed, &mut world2);\n+            println!(\n+                \"Reloaded world with {}x{} map.\",\n+                world2.resource::<GameMap>().width,\n+                world2.resource::<GameMap>().height\n+            );\n+        }\n+        \"cbor\" => {\n+            let bytes = save::encode_cbor(&save).map_err(|e| anyhow::anyhow!(e))?;\n+            println!(\"Serialized (cbor) length: {} bytes\", bytes.len());\n+            let parsed: save::SaveGame =\n+                save::decode_cbor(&bytes).map_err(|e| anyhow::anyhow!(e))?;\n+            let mut world2 = World::new();\n+            load_world(parsed, &mut world2);\n+            println!(\n+                \"Reloaded world with {}x{} map.\",\n+                world2.resource::<GameMap>().width,\n+                world2.resource::<GameMap>().height\n+            );\n+        }\n+        other => {\n+            println!(\"Unknown codec '{}'\", other);\n+            println!(\"Use one of: json|ron|cbor (default json)\");\n+        }\n+    }\n     Ok(())\n }\n "
  },
  {
    "sha": "89627b10020b1fa71241c9e2c6c86ecaf5bdb679",
    "filename": "crates/gc_core/Cargo.toml",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2FCargo.toml",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2FCargo.toml",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2FCargo.toml?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -11,6 +11,8 @@ authors = [\"Goblin Camp Contributors\"]\n bevy_ecs = \"0.14\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n+ron = \"0.8\"\n+ciborium = { version = \"0.2\", features = [\"std\"] }\n rand = \"0.8\"\n thiserror = \"1.0\"\n pathfinding = \"4.9.0\""
  },
  {
    "sha": "a9f5e42b978d500d07ed11c185af584b1a95657e",
    "filename": "crates/gc_core/src/components.rs",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Fsrc%2Fcomponents.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Fsrc%2Fcomponents.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fcomponents.rs?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -58,7 +58,7 @@ pub struct DesignationLifecycle(pub DesignationState);\n /// Types of items that can exist in the world\n /// This enum defines all possible item types that can be created,\n /// carried, and stored in stockpiles. Currently only Stone is implemented.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n pub enum ItemType {\n     /// Stone items created from mining operations\n     /// These are the primary resource produced by mining wall tiles"
  },
  {
    "sha": "cb57fd9f7cdef29994b51e96fdac49acbbffade7",
    "filename": "crates/gc_core/src/save.rs",
    "status": "modified",
    "additions": 85,
    "deletions": 0,
    "changes": 85,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Fsrc%2Fsave.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Fsrc%2Fsave.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fsave.rs?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -1,14 +1,46 @@\n use crate::components::{Carriable, Item, ItemType};\n+use crate::systems;\n use crate::world::{GameMap, Name, Position, TileKind, Velocity};\n use bevy_ecs::prelude::*;\n use serde::{Deserialize, Serialize};\n+use std::io::Cursor;\n+\n+/// Sort entity records in a stable, deterministic order.\n+///\n+/// Ordering key: (name, pos, vel, item_type, carriable)\n+fn sort_entities_deterministically(entities: &mut [EntityData]) {\n+    use std::cmp::Ordering;\n+    entities.sort_by(|a, b| {\n+        let name_ord = a.name.cmp(&b.name);\n+        if name_ord != Ordering::Equal {\n+            return name_ord;\n+        }\n+        let pos_ord = a.pos.cmp(&b.pos);\n+        if pos_ord != Ordering::Equal {\n+            return pos_ord;\n+        }\n+        let vel_ord = a.vel.cmp(&b.vel);\n+        if vel_ord != Ordering::Equal {\n+            return vel_ord;\n+        }\n+        let item_ord = a.item_type.cmp(&b.item_type);\n+        if item_ord != Ordering::Equal {\n+            return item_ord;\n+        }\n+        a.carriable.cmp(&b.carriable)\n+    });\n+}\n \n #[derive(Serialize, Deserialize)]\n pub struct SaveGame {\n     pub width: u32,\n     pub height: u32,\n     pub tiles: Vec<TileKind>,\n     pub entities: Vec<EntityData>,\n+    // Determinism: persist tick timing and RNG seed (per-stream positions planned)\n+    pub tick_ms: u64,\n+    pub ticks: u64,\n+    pub master_seed: u64,\n }\n \n #[derive(Serialize, Deserialize)]\n@@ -44,11 +76,23 @@ pub fn save_world(world: &mut World) -> SaveGame {\n             carriable: carriable.is_some(),\n         });\n     }\n+    // Deterministic ordering across codecs and runs\n+    sort_entities_deterministically(&mut entities);\n+    // Persist determinism metadata\n+    let (tick_ms, ticks) = {\n+        let time = world.resource::<systems::Time>();\n+        (time.tick_ms, time.ticks)\n+    };\n+    let master_seed = world.resource::<systems::DeterministicRng>().master_seed;\n+\n     SaveGame {\n         width,\n         height,\n         tiles,\n         entities,\n+        tick_ms,\n+        ticks,\n+        master_seed,\n     }\n }\n \n@@ -58,6 +102,12 @@ pub fn load_world(save: SaveGame, world: &mut World) {\n         height: save.height,\n         tiles: save.tiles,\n     });\n+    // Restore deterministic time and RNG seed\n+    world.insert_resource(systems::Time {\n+        ticks: save.ticks,\n+        tick_ms: save.tick_ms,\n+    });\n+    world.insert_resource(systems::DeterministicRng::new(save.master_seed));\n     for e in save.entities {\n         let mut ec = world.spawn(());\n         if let Some(name) = e.name {\n@@ -77,3 +127,38 @@ pub fn load_world(save: SaveGame, world: &mut World) {\n         }\n     }\n }\n+\n+// --- Minimal codec helpers (format-agnostic call sites) ---\n+\n+/// Encode a SaveGame to JSON string\n+pub fn encode_json(save: &SaveGame) -> Result<String, serde_json::Error> {\n+    serde_json::to_string(save)\n+}\n+\n+/// Decode a SaveGame from JSON string\n+pub fn decode_json(s: &str) -> Result<SaveGame, serde_json::Error> {\n+    serde_json::from_str(s)\n+}\n+\n+/// Encode a SaveGame to RON string\n+pub fn encode_ron(save: &SaveGame) -> Result<String, ron::Error> {\n+    ron::ser::to_string(save)\n+}\n+\n+/// Decode a SaveGame from RON string\n+pub fn decode_ron(s: &str) -> Result<SaveGame, ron::Error> {\n+    ron::de::from_str(s).map_err(ron::Error::from)\n+}\n+\n+/// Encode a SaveGame to CBOR bytes\n+pub fn encode_cbor(save: &SaveGame) -> Result<Vec<u8>, ciborium::ser::Error<std::io::Error>> {\n+    let mut buf = Vec::new();\n+    ciborium::ser::into_writer(save, &mut buf)?;\n+    Ok(buf)\n+}\n+\n+/// Decode a SaveGame from CBOR bytes\n+pub fn decode_cbor(bytes: &[u8]) -> Result<SaveGame, ciborium::de::Error<std::io::Error>> {\n+    let mut cur = Cursor::new(bytes);\n+    ciborium::de::from_reader(&mut cur)\n+}"
  },
  {
    "sha": "6dd806b6b3098a3965c04672bac701775bd5c111",
    "filename": "crates/gc_core/tests/determinism_tests.rs",
    "status": "modified",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Ftests%2Fdeterminism_tests.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Ftests%2Fdeterminism_tests.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Ftests%2Fdeterminism_tests.rs?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -79,6 +79,29 @@ fn deterministic_behavior_across_systems() {\n     );\n }\n \n+/// Save ordering is stable regardless of entity creation order\n+#[test]\n+fn deterministic_save_entity_ordering() {\n+    let mut world_a = World::new();\n+    world_a.insert_resource(GameMap::new(8, 8));\n+    // Insert in A order\n+    world_a.spawn((Name(\"B\".into()), Position(2, 2)));\n+    world_a.spawn((Name(\"A\".into()), Position(1, 1)));\n+    let save_a = save_world(&mut world_a);\n+\n+    let mut world_b = World::new();\n+    world_b.insert_resource(GameMap::new(8, 8));\n+    // Insert in B order (reverse)\n+    world_b.spawn((Name(\"A\".into()), Position(1, 1)));\n+    world_b.spawn((Name(\"B\".into()), Position(2, 2)));\n+    let save_b = save_world(&mut world_b);\n+\n+    // JSON bytes should be identical once encoded due to stable ordering\n+    let json_a = serde_json::to_string(&save_a).unwrap();\n+    let json_b = serde_json::to_string(&save_b).unwrap();\n+    assert_eq!(json_a, json_b, \"Save ordering should be deterministic\");\n+}\n+\n /// Test that the DeterministicRng resource produces consistent sequences\n #[test]\n fn deterministic_rng_consistent_sequences() {"
  },
  {
    "sha": "3e342ba9cac2b9394902dba11a29c804fd7ac28e",
    "filename": "crates/gc_core/tests/m0_core_tests.rs",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Ftests%2Fm0_core_tests.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/crates%2Fgc_core%2Ftests%2Fm0_core_tests.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Ftests%2Fm0_core_tests.rs?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -32,6 +32,9 @@ fn save_load_roundtrip() {\n \n     let mut w2 = World::new();\n     load_world(serde_json::from_str(&json).unwrap(), &mut w2);\n+    // Validate time and RNG seed restoration\n+    let time = w2.resource::<gc_core::systems::Time>();\n+    assert!(time.tick_ms > 0);\n     let mut q = w2.query::<(&Name, &Position)>();\n     let got: Vec<_> = q.iter(&w2).map(|(n, p)| (n.0.clone(), p.0, p.1)).collect();\n     assert_eq!(got.len(), 1);"
  },
  {
    "sha": "65f983d2e3fc5fc86dd58c3d0fcd39ec08500b99",
    "filename": "scripts/create_graphics_epic.sh",
    "status": "added",
    "additions": 168,
    "deletions": 0,
    "changes": 168,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/scripts%2Fcreate_graphics_epic.sh",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/scripts%2Fcreate_graphics_epic.sh",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/scripts%2Fcreate_graphics_epic.sh?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -0,0 +1,168 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+if ! command -v gh >/dev/null 2>&1; then\n+  echo \"Error: GitHub CLI 'gh' is not installed. Install from https://cli.github.com and retry.\" >&2\n+  exit 1\n+fi\n+\n+if ! gh auth status >/dev/null 2>&1; then\n+  echo \"Error: GitHub CLI is not authenticated. Run: gh auth login\" >&2\n+  exit 1\n+fi\n+\n+EPIC_TITLE=\"Epic: Graphics UI Alpha (gc_gfx)\"\n+EPIC_BODY=$(cat <<'EOF'\n+Goals:\n+- Working, animated, pixel-art tile UI with camera/input.\n+- Reuse existing `bevy_ecs` systems deterministically.\n+- Keep TUI available.\n+\n+Non-goals:\n+- Full menus, save/load UI, audio, advanced art polish.\n+\n+Deliverables:\n+- `gc_gfx` crate; tilemap + sprites; visibility overlay; mouse designations.\n+- Docs: `docs/design/graphics.md`.\n+\n+Risks:\n+- Version mismatches; asset licensing; WSL2 GUI. See epic description for mitigations.\n+\n+Acceptance:\n+- Map + entities render; mining via mouse updates tiles; overlay toggles; 60 FPS on 80x50.\n+EOF\n+)\n+\n+# Ensure labels exist\n+for L in ui graphics bevy epic core tilemap sprites animation input docs assets licensing ci polish refactor gameplay cli integration; do\n+  gh label create \"$L\" --color \"ededed\" --description \"\" >/dev/null 2>&1 || true\n+done\n+\n+# Helper: find first issue URL exactly matching title\n+find_issue_url_by_title () {\n+  local TITLE=\"$1\"\n+  gh issue list --state all --search \"$TITLE in:title\" --json title,url --jq \\\n+    \".[] | select(.title==\\\"$TITLE\\\") | .url\" | head -n 1\n+}\n+\n+# Create epic tracking issue (idempotent)\n+EPIC_URL=$(find_issue_url_by_title \"$EPIC_TITLE\" || true)\n+if [[ -z \"${EPIC_URL:-}\" ]]; then\n+  CREATE_OUT=$(gh issue create --title \"$EPIC_TITLE\" --body \"$EPIC_BODY\" --label epic --label graphics --label ui --assignee \"@me\")\n+  EPIC_URL=$(echo \"$CREATE_OUT\" | grep -Eo 'https://github.com/[^ ]+/issues/[0-9]+' | head -n 1)\n+  # Fallback: re-query if URL not parsed\n+  if [[ -z \"${EPIC_URL:-}\" ]]; then\n+    EPIC_URL=$(find_issue_url_by_title \"$EPIC_TITLE\")\n+  fi\n+  echo \"Created EPIC: $EPIC_URL\"\n+else\n+  echo \"Epic already exists: $EPIC_URL\"\n+fi\n+\n+create_issue () {\n+  local TITLE=\"$1\"\n+  local BODY=\"$2\"\n+  local LABELS=\"$3\"\n+  local DEPENDS_ON=\"${4:-}\"\n+  local URL\n+  local LABEL_ARGS=()\n+  # Expand comma-separated labels into multiple --label flags\n+  IFS=',' read -ra labels_arr <<< \"$LABELS\"\n+  for l in \"${labels_arr[@]}\"; do LABEL_ARGS+=(\"--label\" \"$l\"); done\n+  if [[ -n \"$DEPENDS_ON\" ]]; then\n+    BODY=\"$BODY\n+\n+Depends on: $DEPENDS_ON\"\n+  fi\n+  BODY=\"$BODY\n+\n+Parent epic: $EPIC_URL\"\n+  # Idempotent: check by title first\n+  URL=$(find_issue_url_by_title \"$TITLE\" || true)\n+  if [[ -z \"${URL:-}\" ]]; then\n+    CREATE_OUT=$(gh issue create --title \"$TITLE\" --body \"$BODY\" \"${LABEL_ARGS[@]}\" --assignee \"@me\")\n+    URL=$(echo \"$CREATE_OUT\" | grep -Eo 'https://github.com/[^ ]+/issues/[0-9]+' | head -n 1)\n+    if [[ -z \"${URL:-}\" ]]; then\n+      URL=$(find_issue_url_by_title \"$TITLE\")\n+    fi\n+  fi\n+  echo \"$URL\"\n+}\n+\n+issue1=$(create_issue \"Create Bevy graphics crate gc_gfx and window\" \"Add new workspace crate; Bevy App; pixel camera; nearest sampling.\n+\n+AC:\n+- cargo run -p gc_gfx opens a window with pixel-perfect camera\n+- CI compiles gc_gfx\" \"ui,graphics,bevy\")\n+issue2=$(create_issue \"Refactor bootstrap to support Bevy App world\" \"Expose plugin/setup that inserts core resources/entities into Bevy World.\n+\n+AC:\n+- Core runs in Bevy World (no second World)\n+- Sim behavior unchanged for N ticks\" \"core,bevy,refactor\" \"$issue1\")\n+issue3=$(create_issue \"Integrate core simulation into Bevy schedule\" \"Register systems/time; maintain determinism.\n+\n+AC:\n+- Pause/step parity with TUI for N steps\" \"core,bevy\" \"$issue2\")\n+issue4=$(create_issue \"Add tilemap rendering for GameMap\" \"Use bevy_ecs_tilemap; TileKind->atlas indices; apply diffs.\n+\n+AC:\n+- Tiles render & update on mining\" \"graphics,tilemap\" \"$issue3\")\n+issue5=$(create_issue \"Load and credit a permissive tileset\" \"Add assets/tiles + attribution.\n+\n+AC:\n+- Assets load; README credits present\" \"assets,docs,licensing\" \"$issue1\")\n+issue6=$(create_issue \"Entity sprites for goblins and items\" \"Sprites for Miner/Carrier/Stone; proper z-order.\n+\n+AC:\n+- Sprites at Position; visible with overlay\" \"graphics,sprites\" \"$issue4,$issue5\")\n+issue7=$(create_issue \"Movement tweening and basic sprite animation\" \"Tween between tiles; walk cycle frames.\n+\n+AC:\n+- Smooth movement; idle vs walk frames\" \"graphics,animation\" \"$issue6\")\n+issue8=$(create_issue \"Camera controls and UI overlay\" \"WASD/arrow pan, +/- zoom; HUD text for paused/steps.\n+\n+AC:\n+- Input works; HUD reflects state\" \"ui,input\" \"$issue3\")\n+issue9=$(create_issue \"Visibility overlay layer\" \"Semi-transparent tile overlay from FOV.\n+\n+AC:\n+- Toggleable overlay without perf regressions\" \"graphics\" \"$issue4,$issue8\")\n+issue10=$(create_issue \"Mouse mining designations\" \"Click-drag rectangle spawns MineDesignation.\n+\n+AC:\n+- Mining changes tiles and drops items\" \"input,ui,gameplay\" \"$issue3,$issue4,$issue8\")\n+issue11=$(create_issue \"CLI integration: add gfx demo route\" \"Add 'gfx' subcommand to launch gc_gfx.\n+\n+AC:\n+- goblin-camp gfx launches Bevy UI\" \"cli,integration\" \"$issue1\")\n+issue12=$(create_issue \"Docs: graphics design + runbook\" \"Design doc, assets license notes, WSL/GL troubleshooting.\n+\n+AC:\n+- Clear run instructions and credits\" \"docs\" \"$issue5\")\n+issue13=$(create_issue \"CI build of gc_gfx\" \"Compile-only CI job for gc_gfx.\n+\n+AC:\n+- CI passes on Linux\" \"ci\" \"$issue1\")\n+issue14=$(create_issue \"Polish: water/lava tile animation + particles (optional)\" \"Animate water/lava; simple mining particles.\n+\n+AC:\n+- Visible animated tiles + effect\" \"graphics,polish\" \"$issue7,$issue9\")\n+\n+echo \"Created issues:\"\n+echo \"$issue1\"\n+echo \"$issue2\"\n+echo \"$issue3\"\n+echo \"$issue4\"\n+echo \"$issue5\"\n+echo \"$issue6\"\n+echo \"$issue7\"\n+echo \"$issue8\"\n+echo \"$issue9\"\n+echo \"$issue10\"\n+echo \"$issue11\"\n+echo \"$issue12\"\n+echo \"$issue13\"\n+echo \"$issue14\"\n+echo \"All issues reference EPIC: $EPIC_URL\"\n+\n+"
  },
  {
    "sha": "228305776c0ebbc439d24a7c6252bbe8edebf4dd",
    "filename": "scripts/normalize_graphics_issues.sh",
    "status": "added",
    "additions": 58,
    "deletions": 0,
    "changes": 58,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/fb98cc61b947ec9615ed8286d710e1601133b4c8/scripts%2Fnormalize_graphics_issues.sh",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/fb98cc61b947ec9615ed8286d710e1601133b4c8/scripts%2Fnormalize_graphics_issues.sh",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/scripts%2Fnormalize_graphics_issues.sh?ref=fb98cc61b947ec9615ed8286d710e1601133b4c8",
    "patch": "@@ -0,0 +1,58 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+if ! command -v gh >/dev/null 2>&1; then\n+  echo \"Error: GitHub CLI 'gh' is not installed.\" >&2\n+  exit 1\n+fi\n+\n+EPIC_URL=${EPIC_URL:-\"https://github.com/acaradonna/goblin-camp/issues/181\"}\n+\n+declare -A issue_labels\n+issue_labels[182]=\"ui,graphics,bevy\"\n+issue_labels[193]=\"core,bevy,refactor\"\n+issue_labels[183]=\"core,bevy\"\n+issue_labels[184]=\"graphics,tilemap\"\n+issue_labels[185]=\"assets,docs,licensing\"\n+issue_labels[186]=\"graphics,sprites\"\n+issue_labels[187]=\"graphics,animation\"\n+issue_labels[188]=\"ui,input\"\n+issue_labels[189]=\"graphics\"\n+issue_labels[194]=\"input,ui,gameplay\"\n+issue_labels[195]=\"cli,integration\"\n+issue_labels[190]=\"docs\"\n+issue_labels[191]=\"ci\"\n+issue_labels[192]=\"graphics,polish\"\n+\n+issue_ids=(182 183 184 185 186 187 188 189 190 191 192 193 194 195)\n+\n+for id in \"${issue_ids[@]}\"; do\n+  echo \"Normalizing #$id\"\n+  title=$(gh issue view \"$id\" --json title --jq .title)\n+  labels_expected_csv=${issue_labels[$id]:-}\n+  # Add missing labels only\n+  if [[ -n \"$labels_expected_csv\" ]]; then\n+    IFS=',' read -ra expected <<< \"$labels_expected_csv\"\n+    for lbl in \"${expected[@]}\"; do\n+      # If label is already present, skip\n+      if gh issue view \"$id\" --json labels --jq '.labels[].name' | grep -Fxq \"$lbl\"; then\n+        :\n+      else\n+        gh issue edit \"$id\" --add-label \"$lbl\" >/dev/null\n+      fi\n+    done\n+  fi\n+\n+  # Ensure Parent epic line exists in body\n+  body=$(gh issue view \"$id\" --json body --jq .body)\n+  if ! printf \"%s\" \"$body\" | grep -Fq \"Parent epic:\"; then\n+    tmp=$(mktemp)\n+    printf \"%s\\n\\nParent epic: %s\\n\" \"$body\" \"$EPIC_URL\" > \"$tmp\"\n+    gh issue edit \"$id\" --body-file \"$tmp\" >/dev/null\n+    rm -f \"$tmp\"\n+  fi\n+done\n+\n+echo \"Done.\"\n+\n+"
  }
]
