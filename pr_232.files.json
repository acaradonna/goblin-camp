[
  {
    "sha": "d7b8e86a2dfe8f0d97125b5d7f9536b3b3801a15",
    "filename": "crates/gc_core/src/bootstrap.rs",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/f9564465dd23c96a80e261af753834e1de1c3c93/crates%2Fgc_core%2Fsrc%2Fbootstrap.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/f9564465dd23c96a80e261af753834e1de1c3c93/crates%2Fgc_core%2Fsrc%2Fbootstrap.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fbootstrap.rs?ref=f9564465dd23c96a80e261af753834e1de1c3c93",
    "patch": "@@ -52,6 +52,8 @@ pub fn build_standard_world(width: u32, height: u32, seed: u64, opts: WorldOptio\n     world.insert_resource(jobs::ActiveJobs::default());\n     world.insert_resource(designations::DesignationConfig { auto_jobs: true });\n     world.insert_resource(systems::Time::new(opts.tick_ms));\n+    // Default to stepwise movement to avoid teleporting agents/items in demos\n+    world.insert_resource(systems::MovementConfig::default());\n \n     if opts.populate_demo_scene {\n         // Miner"
  },
  {
    "sha": "2b49c2432ef7998050da58daf5efb0d16233b519",
    "filename": "crates/gc_core/src/systems.rs",
    "status": "modified",
    "additions": 69,
    "deletions": 17,
    "changes": 86,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/f9564465dd23c96a80e261af753834e1de1c3c93/crates%2Fgc_core%2Fsrc%2Fsystems.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/f9564465dd23c96a80e261af753834e1de1c3c93/crates%2Fgc_core%2Fsrc%2Fsystems.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fsystems.rs?ref=f9564465dd23c96a80e261af753834e1de1c3c93",
    "patch": "@@ -76,6 +76,21 @@ pub fn movement(mut q: Query<(&mut Position, &Velocity)>) {\n     }\n }\n \n+/// Movement behavior configuration\n+/// Controls whether job execution teleports or moves stepwise toward targets\n+#[derive(Resource, Debug, Clone, Copy)]\n+pub struct MovementConfig {\n+    /// When true, entities only move one step toward their target per tick\n+    /// When false, systems may teleport to targets for simplicity/tests\n+    pub stepwise: bool,\n+}\n+\n+impl Default for MovementConfig {\n+    fn default() -> Self {\n+        Self { stepwise: true }\n+    }\n+}\n+\n /// Confine positions to map bounds (runs after movement)\n /// Prevents entities from moving outside the valid map area\n /// Clamps positions to the map boundaries for safety\n@@ -149,6 +164,7 @@ pub fn mining_execution_system(\n pub fn hauling_execution_system(\n     _commands: Commands,\n     mut active_jobs: ResMut<ActiveJobs>,\n+    config: Option<Res<MovementConfig>>,\n     mut param_set: ParamSet<(\n         Query<(&mut AssignedJob, &mut Inventory, &mut Position), (With<Carrier>, Without<Miner>)>,\n         Query<(Entity, &mut Position), (With<Item>, With<Carriable>)>,\n@@ -183,25 +199,34 @@ pub fn hauling_execution_system(\n     // Examines all carriers with haul jobs and determines what actions to take\n     {\n         let q_carriers = param_set.p0();\n+        let stepwise = config.map(|c| c.stepwise).unwrap_or(false);\n         for (assigned_job, inventory, carrier_pos) in q_carriers.iter() {\n             if let Some(job_id) = assigned_job.0 {\n                 if let Some(job) = active_jobs.jobs.get(&job_id) {\n                     if let JobKind::Haul { from, to } = job.kind {\n                         if let Some(carried_item) = inventory.0 {\n-                            // Carrier has item, plan to move to destination and drop it\n+                            // Carrier has item, plan movement toward destination\n+                            let target = if stepwise {\n+                                step_toward(carrier_pos.0, carrier_pos.1, to.0, to.1)\n+                            } else {\n+                                to\n+                            };\n+                            let will_drop = !stepwise || (target.0 == to.0 && target.1 == to.1);\n                             carrier_updates.push(CarrierUpdate {\n                                 job_id,\n-                                target: to,\n+                                target,\n                                 from,\n-                                dropping: true,\n+                                dropping: will_drop,\n                                 pickup_item: None,\n                             });\n-                            item_updates.push(ItemUpdate {\n-                                entity: carried_item,\n-                                target: to,\n-                            });\n-                            // Job completes on drop\n-                            completed_jobs.push(job_id);\n+                            if will_drop {\n+                                item_updates.push(ItemUpdate {\n+                                    entity: carried_item,\n+                                    target: to,\n+                                });\n+                                // Job completes on drop\n+                                completed_jobs.push(job_id);\n+                            }\n                         } else {\n                             // Carrier needs to pick up item first\n                             // If carrier is already at the pickup location, only pick up this tick.\n@@ -216,14 +241,27 @@ pub fn hauling_execution_system(\n                                     pickup_item: None,\n                                 });\n                             } else {\n-                                // Plan immediate delivery path for testing compatibility\n-                                carrier_updates.push(CarrierUpdate {\n-                                    job_id,\n-                                    target: to,\n-                                    from,\n-                                    dropping: true,\n-                                    pickup_item: None,\n-                                });\n+                                // Move toward pickup or allow immediate delivery depending on config\n+                                if stepwise {\n+                                    let target =\n+                                        step_toward(carrier_pos.0, carrier_pos.1, from.0, from.1);\n+                                    carrier_updates.push(CarrierUpdate {\n+                                        job_id,\n+                                        target,\n+                                        from,\n+                                        dropping: false,\n+                                        pickup_item: None,\n+                                    });\n+                                } else {\n+                                    // Immediate delivery path for testing compatibility\n+                                    carrier_updates.push(CarrierUpdate {\n+                                        job_id,\n+                                        target: to,\n+                                        from,\n+                                        dropping: true,\n+                                        pickup_item: None,\n+                                    });\n+                                }\n                             }\n                         }\n                     }\n@@ -315,6 +353,20 @@ pub fn hauling_execution_system(\n     }\n }\n \n+/// Take one Manhattan step from (x,y) toward (tx,ty)\n+fn step_toward(x: i32, y: i32, tx: i32, ty: i32) -> (i32, i32) {\n+    let dx = (tx - x).signum();\n+    let dy = (ty - y).signum();\n+    // Move exactly one Manhattan step: prefer horizontal first for determinism\n+    if x != tx {\n+        (x + dx, y)\n+    } else if y != ty {\n+        (x, y + dy)\n+    } else {\n+        (x, y)\n+    }\n+}\n+\n /// Automatically create haul jobs when items are spawned and stockpiles exist\n /// This system creates hauling jobs for newly spawned items (like from mining)\n /// Uses the `Added<Item>` filter to only process items created this tick"
  }
]
