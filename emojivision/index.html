<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EmojiVision - Live Webcam Emoji Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .header {
            background: #111;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            background: #444;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }

        button:hover {
            background: #555;
        }

        button:disabled {
            background: #222;
            cursor: not-allowed;
        }

        .main-content {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        .video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas {
            display: none;
        }

        .emoji-output {
            flex: 1;
            font-family: 'Noto Color Emoji', 'Apple Color Emoji', 'Segoe UI Emoji', 'Courier New', monospace;
            font-size: 8px;
            line-height: 1;
            white-space: pre;
            overflow: hidden;
            padding: 0;
            margin: 0;
            background: #000;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            text-rendering: optimizeSpeed;
            font-variant-emoji: normal;
        }
        
        .emoji-grid {
            display: inline-block;
            font-family: inherit;
            white-space: pre;
            text-align: center;
            letter-spacing: 0;
            word-spacing: 0;
            line-height: 1;
        }
        
        .emoji-row {
            display: block;
            height: 1.2em;
            white-space: nowrap;
            margin: 0;
            padding: 0;
            line-height: 1.2;
        }
        
        .emoji-char {
            display: inline-block;
            width: 1.2em;
            height: 1.2em;
            text-align: center;
            vertical-align: top;
            overflow: visible;
            font-size: inherit;
            line-height: 1.2;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            text-align: center;
            color: #888;
        }

        .error {
            color: #ff6b6b;
        }

        .loading {
            color: #4ecdc4;
        }

        @media (max-width: 768px) {
            .header {
                padding: 8px 16px;
            }
            
            .title {
                font-size: 18px;
            }
            
            .emoji-output {
                font-size: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">ðŸŽ¥ EmojiVision</div>
            <div class="controls">
                <button id="startBtn">Start Camera</button>
                <button id="stopBtn" disabled>Stop Camera</button>
                <button id="snapshotBtn" disabled>ðŸ“¸ Snapshot</button>
                <select id="qualitySelect">
                    <option value="low">Low Quality</option>
                    <option value="medium" selected>Medium Quality</option>
                    <option value="high">High Quality</option>
                </select>
            </div>
        </div>
        
        <div class="main-content">
            <div class="video-container">
                <video id="video" autoplay muted playsinline></video>
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="emoji-output" id="emojiOutput">
                <div class="status" id="status">Click "Start Camera" to begin</div>
            </div>
        </div>
    </div>

    <script>
        class EmojiVision {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.emojiOutput = document.getElementById('emojiOutput');
                this.status = document.getElementById('status');
                
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.snapshotBtn = document.getElementById('snapshotBtn');
                this.qualitySelect = document.getElementById('qualitySelect');
                
                this.stream = null;
                this.animationId = null;
                this.isProcessing = false;
                
                // Texture and pattern-based emoji collections
                this.textureEmojis = {
                    // High contrast patterns - for edges and sharp transitions
                    highContrast: ['âš«', 'â¬›', 'â—¼ï¸', 'â–ªï¸', 'ðŸ”³', 'ðŸ”²', 'â—¾', 'â—½', 'â—»ï¸', 'â–«ï¸', 'â¬œ', 'âšª'],
                    
                    // Geometric patterns - for structured areas
                    geometric: ['ðŸ”¸', 'ðŸ”·', 'ðŸ”¶', 'ðŸ”¹', 'ðŸ”º', 'ðŸ”»', 'ðŸ”¼', 'ðŸ”½', 'â­', 'âœ¨', 'ðŸ’«', 'ðŸŒŸ'],
                    
                    // Organic textures - for natural, flowing areas
                    organic: ['ðŸŒ€', 'ðŸŒŠ', 'ðŸŒªï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'ðŸ«§', 'ðŸ’¦', 'ðŸ’§', 'â˜ï¸', 'â›…', 'ðŸŒ¤ï¸', 'ðŸŒ¦ï¸'],
                    
                    // Fine details - for areas with lots of small variations
                    detailed: ['âœ¨', 'ðŸ’«', 'âš¡', 'ðŸ’¥', 'ðŸŽ†', 'ðŸŽ‡', 'ðŸŒ ', 'â­', 'ðŸŒŸ', 'ðŸ”†', 'ðŸ’¡', 'ðŸ”¥'],
                    
                    // Smooth gradients - for areas with gradual color changes
                    smooth: ['ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒš', 'ðŸŒ›', 'ðŸŒœ', 'ðŸŒ', 'ðŸŒž', 'â˜€ï¸', 'ðŸ”†', 'ðŸ’¡']
                };
                
                // Extensive emoji collection organized by brightness with much more detail
                this.emojiMap = {
                    // Very dark emojis (0-15% brightness) - deep shadows and pure blacks
                    veryDark: ['âš«', 'â¬›', 'â—¼ï¸', 'â–ªï¸', 'ðŸ•³ï¸', 'ðŸŒ‘', 'ðŸŒš', 'ðŸ–¤', 'â™ ï¸', 'ðŸŽ±', 'ðŸ•·ï¸', 'ðŸ¦‡', 'ðŸœ', 'ðŸª²', 'ðŸ•¸ï¸', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸŒ ', 'â­', 'ðŸ’«', 'ðŸ”²', 'â—¾', 'â–«ï¸', 'ðŸ”³', 'ðŸŸ«', 'ðŸ¤Ž', 'ðŸª¨', 'ðŸ—»', 'â›°ï¸', 'ðŸ”ï¸'],
                    
                    // Dark emojis (15-30% brightness) - deep grays and dark tones
                    dark: ['ðŸ”˜', 'ðŸ”´', 'ðŸŸ¤', 'ðŸŸ«', 'ðŸ»', 'ðŸ¦', 'ðŸ§', 'ðŸ¦¨', 'ðŸœ', 'ðŸ•·ï¸', 'ðŸª²', 'ðŸ¦‚', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒš', 'âš¡', 'ðŸŒªï¸', 'ðŸŒŠ', 'ðŸ’™', 'ðŸ”µ', 'ðŸŸ¦', 'ðŸ”·', 'ðŸ”¹', 'ðŸ’Ž', 'ðŸŒ€', 'ðŸª¨', 'ðŸ—»', 'â›°ï¸', 'ðŸ”ï¸', 'ðŸŒ‹', 'ðŸŽ–ï¸', 'ðŸ›¡ï¸', 'âš™ï¸', 'ðŸ”©', 'ðŸ”§', 'ðŸ”¨', 'â›ï¸', 'ðŸª“', 'ðŸ—¡ï¸'],
                    
                    // Medium-dark emojis (30-45% brightness) - mid-grays with some luminance
                    mediumDark: ['ðŸ”˜', 'ðŸŸ«', 'ðŸ¤Ž', 'ðŸŸ¤', 'ðŸ„', 'ðŸŒ°', 'ðŸ¥¥', 'ðŸª¨', 'ðŸ—»', 'â›°ï¸', 'ðŸ”ï¸', 'ðŸŒ‹', 'ðŸ”¥', 'ðŸŒ™', 'ðŸŒ›', 'ðŸŒœ', 'ðŸŒ', 'ðŸŒž', 'â˜€ï¸', 'ðŸ”†', 'ðŸ’«', 'âœ¨', 'â­', 'ðŸŒŸ', 'ðŸ’¥', 'ðŸŽ†', 'ðŸŽ‡', 'ðŸŒˆ', 'ðŸ¦‹', 'ðŸ›', 'ðŸª²', 'ðŸ¦—', 'ðŸª°', 'ðŸ', 'ðŸª³', 'ðŸ¦‚', 'ðŸ•·ï¸', 'ðŸ»', 'ðŸ¦Œ', 'ðŸ´', 'ðŸŽ', 'ðŸ¦¬', 'ðŸ‚', 'ðŸƒ', 'ðŸ¦', 'ðŸ˜'],
                    
                    // Medium emojis (45-60% brightness) - balanced mid-tones
                    medium: ['â˜ï¸', 'â›…', 'ðŸŒ¤ï¸', 'â›ˆï¸', 'ðŸŒ¦ï¸', 'ðŸŒ§ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'ðŸŒŠ', 'ðŸŒ€', 'ðŸŒªï¸', 'ðŸ”®', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸŸ¤', 'ðŸŸ«', 'ðŸ”¶', 'ðŸ”¸', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£', 'ðŸŸª', 'âšª', 'â¬œ', 'â–«ï¸', 'â—½', 'â—»ï¸', 'ðŸ”³', 'ðŸ”²', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ¹', 'ðŸŒ·', 'ðŸŒ¼', 'ðŸŒ¿', 'ðŸ€', 'â˜˜ï¸', 'ðŸŒ±', 'ðŸŒ³', 'ðŸŒ²', 'ðŸŽ„'],
                    
                    // Medium-light emojis (60-75% brightness) - lighter tones with good contrast
                    mediumLight: ['ðŸ¤', 'ðŸ¤Ž', 'ðŸŸ¤', 'ðŸŸ«', 'ðŸ”¶', 'ðŸ”¸', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£', 'ðŸŸª', 'âšª', 'â¬œ', 'â–«ï¸', 'â—½', 'â—»ï¸', 'ðŸ”³', 'ðŸ”²', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ¹', 'ðŸŒ·', 'ðŸŒ¼', 'ðŸŒ¿', 'ðŸ€', 'â˜˜ï¸', 'ðŸŒ±', 'ðŸŒ³', 'ðŸŒ²', 'ðŸŽ„', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸƒ', 'ðŸŒµ', 'ðŸ¸', 'ðŸ¦Ž', 'ðŸ¢', 'ðŸ', 'ðŸ›', 'ðŸ¦—', 'ðŸª°', 'ðŸ', 'ðŸª³', 'ðŸ¦‚', 'ðŸ•·ï¸', 'ðŸ³', 'ðŸ‹', 'ðŸ¬', 'ðŸ¦ˆ', 'ðŸ™', 'ðŸ¦‘', 'ðŸ¦', 'ðŸ¦€', 'ðŸ¦ž'],
                    
                    // Light emojis (75-90% brightness) - bright but not pure white
                    light: ['ðŸ’«', 'âœ¨', 'ðŸŒŸ', 'â­', 'ðŸŒ ', 'ðŸ’¥', 'ðŸŽ†', 'ðŸŽ‡', 'ðŸŽŠ', 'ðŸŽ‰', 'ðŸŽˆ', 'ðŸŽ€', 'ðŸŽ', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ¹', 'ðŸŒ·', 'ðŸŒ¼', 'ðŸŒ¿', 'ðŸ€', 'â˜˜ï¸', 'ðŸŒ±', 'ðŸŒ³', 'ðŸŒ²', 'ðŸŽ„', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸƒ', 'ðŸŒµ', 'ðŸ’', 'ðŸ’Ž', 'ðŸ”†', 'ðŸ’¡', 'ðŸ”¥', 'âš¡', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'ðŸŒŠ', 'ðŸŒ€', 'ðŸŒªï¸', 'ðŸ”®', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š'],
                    
                    // Very light emojis (90-100% brightness) - near-white and pure white
                    veryLight: ['âšª', 'â¬œ', 'â–«ï¸', 'â—½', 'â—»ï¸', 'ðŸ¤', 'ðŸ’', 'ðŸ’Ž', 'âœ¨', 'ðŸ’«', 'ðŸŒŸ', 'â­', 'ðŸŒ ', 'â˜€ï¸', 'ðŸŒž', 'ðŸ”†', 'ðŸ’¡', 'ðŸ”¥', 'âš¡', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'ðŸ•Šï¸', 'ðŸ¦¢', 'ðŸ‘', 'ðŸ', 'ðŸ¦™', 'ðŸ¦†', 'ðŸ‡', 'ðŸ°', 'ðŸ¤', 'ðŸ’', 'ðŸ”®', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š', 'â˜ï¸', 'â›…', 'ðŸŒ¤ï¸', 'ðŸŒ¦ï¸', 'ðŸŒ§ï¸']
                };
                
                // Comprehensive color-specific emoji mappings with brightness gradients
                this.colorEmojiMap = {
                    red: {
                        veryDark: ['ðŸŸ«', 'ðŸ¤Ž', 'ðŸ”´', 'ðŸ¦ž', 'ðŸ¦€', 'ðŸŒ‹', 'ðŸ”¥', 'ðŸ’¥', 'ðŸŒ¶ï¸', 'ðŸ’'],
                        dark: ['ðŸ”´', 'ðŸŸ¥', 'â¤ï¸', 'ðŸŽ', 'ðŸ“', 'ðŸ’', 'ðŸŒ¶ï¸', 'ðŸŒ¹', 'ðŸ¦ž', 'ðŸ¦€', 'ðŸ”¥', 'ðŸ’¥', 'â—', 'â­•', 'ðŸ›‘', 'ðŸš¨'],
                        medium: ['ðŸŽ', 'ðŸ“', 'ðŸ’', 'ðŸŒ¹', 'ðŸŒº', 'ðŸŽˆ', 'ðŸŽ€', 'ðŸ’ƒ', 'ðŸ‘º', 'ðŸ‘¹', 'ðŸ¦©', 'ðŸ§§', 'ðŸ“•', 'ðŸ„', 'ðŸž', 'ðŸ¦'],
                        light: ['ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'ðŸŽˆ', 'ðŸŽ€', 'ðŸ¦©', 'ðŸ·', 'ðŸ½', 'ðŸ§ ', 'ðŸ¥©', 'ðŸ‘', 'ðŸŒ¶ï¸'],
                        veryLight: ['ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'ðŸŽ€', 'ðŸ¦©', 'ðŸ§ ', 'ðŸ‘', 'ðŸ¥©', 'ðŸ„', 'ðŸŒ¹', 'ðŸ’…', 'ðŸ‘›', 'ðŸŽˆ']
                    },
                    orange: {
                        veryDark: ['ðŸŸ«', 'ðŸ¤Ž', 'ðŸ”¶', 'ðŸ§¡', 'ðŸ¦Š', 'ðŸ¦', 'ðŸ…', 'ðŸ¯', 'ðŸ¦Œ', 'ðŸ´'],
                        dark: ['ðŸŸ ', 'ðŸ”¶', 'ðŸ§¡', 'ðŸŠ', 'ðŸ¥•', 'ðŸŽƒ', 'ðŸ¦Š', 'ðŸŒ…', 'ðŸŒ„', 'ðŸ”¥', 'ðŸ’¥', 'ðŸŒ‹', 'ðŸ¦', 'ðŸ…', 'ðŸ¯'],
                        medium: ['ðŸŠ', 'ðŸ¥•', 'ðŸŽƒ', 'ðŸ¦Š', 'ðŸŒ…', 'ðŸŒ„', 'ðŸ¦', 'ðŸ…', 'ðŸ¯', 'ðŸŸ§', 'ðŸ“™', 'ðŸ§¿', 'ðŸŽˆ', 'ðŸ¦‹', 'ðŸ€', 'ðŸ“¦', 'ðŸ¯', 'ðŸ§ˆ', 'ðŸ¥–', 'ðŸ¥¨'],
                        light: ['ðŸŠ', 'ðŸ¥•', 'ðŸŽƒ', 'ðŸŒ…', 'ðŸŒ„', 'ðŸŸ§', 'ðŸ“™', 'ðŸ§¿', 'ðŸŽˆ', 'ðŸ¦‹', 'ðŸ€', 'ðŸ“¦', 'ðŸ¯', 'ðŸ§ˆ', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ§¡', 'ðŸŒ»', 'ðŸŒ¼', 'â­'],
                        veryLight: ['ðŸŒ»', 'ðŸŒ¼', 'â­', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'ðŸ”†', 'ðŸ’¡', 'ðŸŽƒ', 'ðŸŠ', 'ðŸ¥•', 'ðŸŸ§', 'ðŸ“™', 'ðŸ§¿', 'ðŸŽˆ', 'ðŸ¦‹', 'ðŸ€', 'ðŸ“¦', 'ðŸ¯', 'ðŸ§ˆ']
                    },
                    yellow: {
                        veryDark: ['ðŸŸ«', 'ðŸ¤Ž', 'ðŸŸ¨', 'ðŸ’›', 'ðŸŒ•', 'ðŸŒž', 'â˜€ï¸', 'â­', 'ðŸŒŸ', 'âœ¨'],
                        dark: ['ðŸŸ¡', 'ðŸŸ¨', 'ðŸ’›', 'ðŸŒ•', 'ðŸŒž', 'â˜€ï¸', 'â­', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'ðŸŒ™', 'ðŸŒ', 'ðŸŒ›', 'ðŸŒœ'],
                        medium: ['ðŸŒž', 'â˜€ï¸', 'â­', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'ðŸŒ™', 'ðŸŒ', 'ðŸŒ›', 'ðŸŒœ', 'ðŸ”†', 'ðŸ’¡', 'ðŸ”¥', 'âš¡', 'ðŸŒ»', 'ðŸŒ¼', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ', 'ðŸ§€'],
                        light: ['ðŸŒ»', 'ðŸŒ¼', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ', 'ðŸ§€', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ§ˆ', 'ðŸ¯', 'ðŸ', 'ðŸª³', 'ðŸ¦—', 'ðŸ›', 'ðŸŽ¾', 'ðŸŽ—ï¸', 'ðŸŽ«', 'ðŸ“’', 'ðŸ“', 'âœï¸'],
                        veryLight: ['â­', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'ðŸ”†', 'ðŸ’¡', 'â˜€ï¸', 'ðŸŒž', 'ðŸŒ»', 'ðŸŒ¼', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ', 'ðŸ§€', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ§ˆ', 'ðŸ¯', 'ðŸ', 'ðŸª³']
                    },
                    green: {
                        veryDark: ['ðŸŒ²', 'ðŸŽ„', 'ðŸŒ³', 'ðŸŒ¿', 'ðŸ€', 'ðŸŒ±', 'ðŸ¢', 'ðŸ', 'ðŸ›', 'ðŸ¦—'],
                        dark: ['ðŸŸ¢', 'ðŸŸ©', 'ðŸ’š', 'ðŸŒ¿', 'ðŸ€', 'ðŸŒ±', 'ðŸŒ³', 'ðŸŒ²', 'ðŸŽ„', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸ¸', 'ðŸ¦Ž', 'ðŸ¢', 'ðŸ'],
                        medium: ['ðŸŒ¿', 'ðŸ€', 'ðŸŒ±', 'ðŸŒ³', 'ðŸŒ²', 'ðŸŽ„', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸ¸', 'ðŸ¦Ž', 'ðŸ¢', 'ðŸ', 'ðŸ›', 'ðŸ¦—', 'ðŸŒµ', 'ðŸƒ', 'â˜˜ï¸', 'ðŸ¥¦', 'ðŸ¥', 'ðŸ'],
                        light: ['ðŸ¸', 'ðŸ¦Ž', 'ðŸ¢', 'ðŸ', 'ðŸ›', 'ðŸ¦—', 'ðŸŒµ', 'ðŸƒ', 'â˜˜ï¸', 'ðŸ¥¦', 'ðŸ¥', 'ðŸ', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸŒ¿', 'ðŸ€', 'ðŸŒ±', 'ðŸ’š', 'ðŸŸ¢', 'ðŸŸ©'],
                        veryLight: ['ðŸŒ¿', 'ðŸ€', 'ðŸŒ±', 'ðŸ’š', 'ðŸŸ¢', 'ðŸŸ©', 'ðŸŒµ', 'ðŸƒ', 'â˜˜ï¸', 'ðŸ¥¦', 'ðŸ¥', 'ðŸ', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸ¸', 'ðŸ¦Ž', 'ðŸ¢', 'ðŸ', 'ðŸ›', 'ðŸ¦—']
                    },
                    blue: {
                        veryDark: ['ðŸ”µ', 'ðŸŸ¦', 'ðŸ’™', 'ðŸŒ€', 'ðŸŒŠ', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š', 'â„ï¸'],
                        dark: ['ðŸ”µ', 'ðŸŸ¦', 'ðŸ’™', 'ðŸŒ€', 'ðŸŒŠ', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸŒ§ï¸', 'â›ˆï¸'],
                        medium: ['ðŸŒŠ', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸŒ§ï¸', 'â›ˆï¸', 'ðŸŒ¦ï¸', 'ðŸŒ¤ï¸', 'â›…', 'â˜ï¸', 'ðŸ‹', 'ðŸ³', 'ðŸ¬', 'ðŸ¦ˆ', 'ðŸ™'],
                        light: ['ðŸ‹', 'ðŸ³', 'ðŸ¬', 'ðŸ¦ˆ', 'ðŸ™', 'ðŸ¦‘', 'ðŸ¦', 'ðŸ¦€', 'ðŸ¦ž', 'ðŸ’Ž', 'ðŸ”®', 'ðŸ§¿', 'ðŸŽˆ', 'ðŸ¦‹', 'ðŸŒŒ', 'ðŸŒƒ', 'ðŸŒ ', 'â­', 'ðŸŒŸ', 'âœ¨'],
                        veryLight: ['ðŸ’Ž', 'ðŸ”®', 'ðŸ§¿', 'ðŸŽˆ', 'ðŸ¦‹', 'ðŸŒŒ', 'ðŸŒƒ', 'ðŸŒ ', 'â­', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'ðŸ”†', 'ðŸ’¡', 'â˜ï¸', 'â›…', 'ðŸŒ¤ï¸', 'ðŸŒ¦ï¸', 'ðŸŒ§ï¸', 'â›ˆï¸']
                    },
                    purple: {
                        veryDark: ['ðŸŸ£', 'ðŸŸª', 'ðŸ’œ', 'ðŸ”®', 'ðŸ‡', 'ðŸ†', 'ðŸ‘¾', 'ðŸŽ†', 'ðŸŒŒ', 'ðŸŒƒ'],
                        dark: ['ðŸŸ£', 'ðŸŸª', 'ðŸ’œ', 'ðŸ”®', 'ðŸ‡', 'ðŸ†', 'ðŸ‘¾', 'ðŸŽ†', 'ðŸŒŒ', 'ðŸŒƒ', 'ðŸ¦„', 'ðŸ¦‹', 'ðŸ’Ÿ', 'â˜‚ï¸', 'ðŸŽµ'],
                        medium: ['ðŸ‡', 'ðŸ†', 'ðŸ‘¾', 'ðŸŽ†', 'ðŸŒŒ', 'ðŸŒƒ', 'ðŸ¦„', 'ðŸ¦‹', 'ðŸ’Ÿ', 'â˜‚ï¸', 'ðŸŽµ', 'ðŸŽ¶', 'ðŸ”¯', 'âœ¡ï¸', 'â˜®ï¸', 'ðŸ•‰ï¸', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸ§ž'],
                        light: ['ðŸ¦„', 'ðŸ¦‹', 'ðŸ’Ÿ', 'â˜‚ï¸', 'ðŸŽµ', 'ðŸŽ¶', 'ðŸ”¯', 'âœ¡ï¸', 'â˜®ï¸', 'ðŸ•‰ï¸', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸ§ž', 'ðŸ”®', 'ðŸ’œ', 'ðŸŸ£', 'ðŸŸª', 'ðŸ‘¾', 'ðŸŽ†'],
                        veryLight: ['ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'ðŸŽ€', 'ðŸ§ž', 'ðŸ”®', 'ðŸ’œ', 'ðŸŸ£', 'ðŸŸª', 'ðŸ‘¾', 'ðŸŽ†', 'ðŸŒŒ', 'ðŸŒƒ']
                    },
                    pink: {
                        veryDark: ['ðŸ©·', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'ðŸŒ¸', 'ðŸŒº'],
                        dark: ['ðŸ©·', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸŽ€', 'ðŸ’…', 'ðŸ‘›'],
                        medium: ['ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸŽ€', 'ðŸ’…', 'ðŸ‘›', 'ðŸ¦©', 'ðŸ·', 'ðŸ½', 'ðŸŽˆ', 'ðŸ§ ', 'ðŸ‘', 'ðŸ¥©', 'ðŸ„', 'ðŸŒ¹', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•'],
                        light: ['ðŸ¦©', 'ðŸ·', 'ðŸ½', 'ðŸŽˆ', 'ðŸ§ ', 'ðŸ‘', 'ðŸ¥©', 'ðŸ„', 'ðŸŒ¹', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸŽ€'],
                        veryLight: ['ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸŽ€', 'ðŸ’…', 'ðŸ‘›', 'ðŸ¦©', 'ðŸ·', 'ðŸ½', 'ðŸŽˆ', 'ðŸ§ ', 'ðŸ‘', 'ðŸ¥©']
                    },
                    brown: {
                        veryDark: ['ðŸ¤Ž', 'ðŸŸ¤', 'ðŸŸ«', 'ðŸŒ°', 'ðŸ¥¥', 'ðŸ„', 'ðŸ¦«', 'ðŸ»', 'ðŸ¦Œ', 'ðŸ´'],
                        dark: ['ðŸ¤Ž', 'ðŸŸ¤', 'ðŸŸ«', 'ðŸŒ°', 'ðŸ¥¥', 'ðŸ„', 'ðŸ¦«', 'ðŸ»', 'ðŸ¦Œ', 'ðŸ´', 'ðŸŽ', 'ðŸ¦¬', 'ðŸ‚', 'ðŸƒ', 'ðŸ¦'],
                        medium: ['ðŸŒ°', 'ðŸ¥¥', 'ðŸ„', 'ðŸ¦«', 'ðŸ»', 'ðŸ¦Œ', 'ðŸ´', 'ðŸŽ', 'ðŸ¦¬', 'ðŸ‚', 'ðŸƒ', 'ðŸ¦', 'ðŸ˜', 'ðŸ¦£', 'ðŸª', 'ðŸ«', 'ðŸ¥–', 'ðŸž', 'ðŸ§ˆ', 'ðŸ¥¨'],
                        light: ['ðŸ˜', 'ðŸ¦£', 'ðŸª', 'ðŸ«', 'ðŸ¥–', 'ðŸž', 'ðŸ§ˆ', 'ðŸ¥¨', 'ðŸ¥¯', 'ðŸ§‡', 'ðŸ¥ž', 'ðŸª', 'ðŸ°', 'ðŸ§', 'ðŸ¯', 'ðŸ¥œ', 'ðŸŒ°', 'ðŸ¥¥', 'ðŸ„', 'ðŸ¦«'],
                        veryLight: ['ðŸ¥–', 'ðŸž', 'ðŸ§ˆ', 'ðŸ¥¨', 'ðŸ¥¯', 'ðŸ§‡', 'ðŸ¥ž', 'ðŸª', 'ðŸ°', 'ðŸ§', 'ðŸ¯', 'ðŸ¥œ', 'ðŸŒ°', 'ðŸ¥¥', 'ðŸ„', 'ðŸ¦«', 'ðŸ»', 'ðŸ¦Œ', 'ðŸ´', 'ðŸŽ']
                    },
                    white: {
                        veryDark: ['âšª', 'â¬œ', 'ðŸ¤', 'â˜ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸'],
                        dark: ['âšª', 'â¬œ', 'ðŸ¤', 'â˜ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸ•Šï¸', 'ðŸ¦¢', 'ðŸ‘', 'ðŸ', 'ðŸ¦™'],
                        medium: ['â˜ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸ•Šï¸', 'ðŸ¦¢', 'ðŸ‘', 'ðŸ', 'ðŸ¦™', 'ðŸ¦†', 'ðŸ‡', 'ðŸ°', 'ðŸ¤', 'ðŸ’', 'ðŸ”®', 'ðŸ’§', 'ðŸ’¦'],
                        light: ['ðŸ•Šï¸', 'ðŸ¦¢', 'ðŸ‘', 'ðŸ', 'ðŸ¦™', 'ðŸ¦†', 'ðŸ‡', 'ðŸ°', 'ðŸ¤', 'ðŸ’', 'ðŸ”®', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š', 'âšª', 'â¬œ', 'â˜ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸'],
                        veryLight: ['âšª', 'â¬œ', 'ðŸ¤', 'ðŸ’', 'ðŸ”®', 'ðŸ’§', 'ðŸ’¦', 'ðŸ«§', 'ðŸ§Š', 'â˜ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¨ï¸', 'ðŸ•Šï¸', 'ðŸ¦¢', 'ðŸ‘', 'ðŸ']
                    },
                    black: {
                        veryDark: ['âš«', 'â¬›', 'ðŸ–¤', 'ðŸŒ‘', 'ðŸŒš', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸ•³ï¸', 'ðŸ¦‡', 'ðŸˆâ€â¬›'],
                        dark: ['âš«', 'â¬›', 'ðŸ–¤', 'ðŸŒ‘', 'ðŸŒš', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸ•³ï¸', 'ðŸ¦‡', 'ðŸˆâ€â¬›', 'ðŸ§', 'ðŸ¦¨', 'ðŸœ', 'ðŸ•·ï¸', 'ðŸ¦‚'],
                        medium: ['ðŸŒ‘', 'ðŸŒš', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸ•³ï¸', 'ðŸ¦‡', 'ðŸˆâ€â¬›', 'ðŸ§', 'ðŸ¦¨', 'ðŸœ', 'ðŸ•·ï¸', 'ðŸ¦‚', 'ðŸ»', 'ðŸ¦', 'â™ ï¸', 'ðŸŽ±', 'ðŸ”²', 'â—¼ï¸', 'â–ªï¸', 'ðŸ”³'],
                        light: ['ðŸ§', 'ðŸ¦¨', 'ðŸœ', 'ðŸ•·ï¸', 'ðŸ¦‚', 'ðŸ»', 'ðŸ¦', 'â™ ï¸', 'ðŸŽ±', 'ðŸ”²', 'â—¼ï¸', 'â–ªï¸', 'ðŸ”³', 'âš«', 'â¬›', 'ðŸ–¤', 'ðŸŒ‘', 'ðŸŒš', 'ðŸŒƒ', 'ðŸŒŒ'],
                        veryLight: ['âš«', 'â¬›', 'ðŸ–¤', 'ðŸŒ‘', 'ðŸŒš', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸ•³ï¸', 'ðŸ¦‡', 'ðŸˆâ€â¬›', 'ðŸ§', 'ðŸ¦¨', 'ðŸœ', 'ðŸ•·ï¸', 'ðŸ¦‚', 'ðŸ»', 'ðŸ¦', 'â™ ï¸', 'ðŸŽ±', 'ðŸ”²']
                    }
                };
                
                // Brightness ranges for emoji selection
                this.brightnessRanges = [
                    { min: 0, max: 38, category: 'veryDark' },
                    { min: 38, max: 76, category: 'dark' },
                    { min: 76, max: 114, category: 'mediumDark' },
                    { min: 114, max: 152, category: 'medium' },
                    { min: 152, max: 190, category: 'mediumLight' },
                    { min: 190, max: 228, category: 'light' },
                    { min: 228, max: 255, category: 'veryLight' }
                ];
                
                // Cache for analyzing surrounding pixels
                this.analysisCache = new Map();
                
                // Previous frame data for temporal analysis
                this.previousFrame = null;
                this.frameCount = 0;
                
                // Emoji usage tracking to prevent repetition
                this.emojiUsageMap = new Map();
                this.lastUsedEmojis = new Map(); // Track last used emoji per position
                
                // Edge-specific emoji collections with directional patterns
                this.edgeEmojis = {
                    strong: ['âš«', 'â¬›', 'â—¼ï¸', 'â–ªï¸', 'ðŸ”³', 'ðŸ”²', 'â—¾', 'â—½', 'â¬œ', 'âšª'],
                    medium: ['ðŸ”¸', 'ðŸ”·', 'ðŸ”¶', 'ðŸ”¹', 'âœ¨', 'ðŸ’«', 'âš¡', 'ðŸ’¥'],
                    soft: ['â˜ï¸', 'â›…', 'ðŸŒ¤ï¸', 'ðŸ’¨', 'ðŸŒ¬ï¸', 'ðŸ«§', 'ðŸ’¦', 'ðŸ’§'],
                    coloredStrong: {
                        red: ['ðŸ”´', 'â¤ï¸', 'ðŸŸ¥', 'â­•', 'â—', 'ðŸ›‘'],
                        blue: ['ðŸ”µ', 'ðŸŸ¦', 'ðŸ’™', 'ðŸŒ€', 'ðŸŒŠ', 'ðŸ’§'],
                        green: ['ðŸŸ¢', 'ðŸŸ©', 'ðŸ’š', 'ðŸŒ¿', 'ðŸ€', 'ðŸŒ±'],
                        yellow: ['ðŸŸ¡', 'ðŸŸ¨', 'ðŸ’›', 'â­', 'ðŸŒŸ', 'âœ¨'],
                        orange: ['ðŸŸ ', 'ðŸ”¶', 'ðŸ§¡', 'ðŸŠ', 'ðŸ¥•', 'ðŸŽƒ'],
                        purple: ['ðŸŸ£', 'ðŸŸª', 'ðŸ’œ', 'ðŸ”®', 'ðŸ‡', 'ðŸ†']
                    }
                };
                
                // Massive green emoji collection for stylish greyscale-to-green mapping
                this.greenEmojis = {
                    // Ultra-bright greens (240-255 brightness)
                    ultraBright: ['âœ¨', 'ðŸŒŸ', 'â­', 'ðŸ’«', 'âš¡', 'ðŸ’¥', 'ðŸŽ†', 'ðŸŽ‡', 'ðŸŒ ', 'ðŸ”†', 'ðŸ’¡', 'ðŸ”¥'],
                    
                    // Very bright greens (210-240 brightness)
                    veryBright: ['ðŸŸ¢', 'ðŸ’š', 'ðŸŒ¿', 'ðŸ€', 'â˜˜ï¸', 'ðŸŒ±', 'ðŸŒ¾', 'ðŸ¥¦', 'ðŸ¥', 'ðŸ', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸŒµ', 'ðŸƒ', 'ðŸ‚'],
                    
                    // Bright greens (180-210 brightness)
                    bright: ['ðŸŸ©', 'ðŸŒ³', 'ðŸŒ²', 'ðŸŽ„', 'ðŸŒ´', 'ðŸŒ¼', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸ’', 'ðŸŽ', 'ðŸ‹', 'ðŸŒ', 'ðŸ‰', 'ðŸ‡', 'ðŸ“', 'ðŸ«', 'ðŸˆ'],
                    
                    // Medium-bright greens (150-180 brightness)
                    mediumBright: ['ðŸ’', 'ðŸ‘', 'ðŸ¥­', 'ðŸ', 'ðŸ¥¥', 'ðŸ¥', 'ðŸ…', 'ðŸ¥”', 'ðŸ†', 'ðŸ¥•', 'ðŸŒ½', 'ðŸŒ¶ï¸', 'ðŸ«‘', 'ðŸ¥’', 'ðŸ¥¬', 'ðŸ¥¦', 'ðŸ§„', 'ðŸ§…', 'ðŸ„', 'ðŸ¥œ'],
                    
                    // Medium greens (120-150 brightness)
                    medium: ['ðŸŒ°', 'ðŸž', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ¸', 'ðŸ¦Ž', 'ðŸ¢', 'ðŸ', 'ðŸ›', 'ðŸ¦—', 'ðŸª°', 'ðŸ', 'ðŸª³', 'ðŸ¦‚', 'ðŸŒŠ', 'ðŸŒŒ', 'ðŸ”ï¸', 'â›°ï¸', 'ðŸŽ–ï¸', 'ðŸŒ‹'],
                    
                    // Medium-dark greens (90-120 brightness)
                    mediumDark: ['ðŸŒ²', 'ðŸŒ³', 'ðŸŽ„', 'ðŸŒ´', 'ðŸŒµ', 'ðŸŒ¿', 'ðŸ€', 'â˜˜ï¸', 'ðŸŒ±', 'ðŸŒ¾', 'ðŸŠ', 'ðŸ³', 'ðŸ¬', 'ðŸ¦ˆ', 'ðŸ™', 'ðŸ¦‘', 'ðŸ¦', 'ðŸ¦€', 'ðŸ¦ž', 'ðŸŒ€'],
                    
                    // Dark greens (60-90 brightness)
                    dark: ['ðŸŒ²', 'ðŸŒ³', 'ðŸŽ„', 'ðŸŒ‹', 'ðŸŽ–ï¸', 'ðŸ”ï¸', 'â›°ï¸', 'ðŸŒŒ', 'ðŸŒƒ', 'ðŸŒ ', 'ðŸŒŠ', 'ðŸ¢', 'ðŸ', 'ðŸ¦Ž', 'ðŸ¸', 'ðŸ¦—', 'ðŸª°', 'ðŸ', 'ðŸª³', 'ðŸ¦‚'],
                    
                    // Very dark greens (30-60 brightness)
                    veryDark: ['ðŸŒ²', 'ðŸŒ³', 'ðŸŽ„', 'ðŸŒ‹', 'ðŸŒŒ', 'ðŸŒƒ', 'ðŸŒ ', 'ðŸ•·ï¸', 'ðŸª²', 'ðŸ¦‚', 'ðŸœ', 'ðŸ', 'ðŸ¦Ž', 'ðŸ¢', 'ðŸ¸', 'ðŸŸ«', 'ðŸ¤Ž', 'ðŸŸ¤', 'â¬›', 'â—¼ï¸'],
                    
                    // Ultra-dark greens (0-30 brightness)
                    ultraDark: ['â¬›', 'â—¼ï¸', 'â–ªï¸', 'ðŸ”²', 'ðŸŸ¤', 'ðŸ¤Ž', 'ðŸŸ«', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸŒ ', 'ðŸ•³ï¸', 'ðŸ¦‡', 'ðŸˆâ€â¬›', 'ðŸ§', 'ðŸ¦¨', 'ðŸœ', 'ðŸ•·ï¸', 'ðŸª²', 'ðŸ¦‚', 'ðŸ»']
                };
                
                // Frame counter for temporal variation
                this.frameCounter = 0;
                
                this.initEventListeners();
                this.handleResize();
                window.addEventListener('resize', () => this.handleResize());
            }
            
            initEventListeners() {
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.snapshotBtn.addEventListener('click', () => this.takeSnapshot());
                this.qualitySelect.addEventListener('change', () => this.handleResize());
            }
            
            async startCamera() {
                try {
                    this.showStatus('Requesting camera access...', 'loading');
                    
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    this.video.srcObject = this.stream;
                    
                    this.video.addEventListener('loadedmetadata', () => {
                        this.handleResize();
                        this.startProcessing();
                        this.updateUI(true);
                        this.hideStatus();
                    });
                    
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    this.showStatus('Camera access denied or not available', 'error');
                }
            }
            
            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                this.updateUI(false);
                this.showStatus('Camera stopped', '');
            }
            
            startProcessing() {
                const processFrame = () => {
                    if (this.stream && !this.isProcessing) {
                        this.isProcessing = true;
                        this.processVideoFrame();
                        this.isProcessing = false;
                    }
                    this.animationId = requestAnimationFrame(processFrame);
                };
                processFrame();
            }
            
            processVideoFrame() {
                if (this.video.readyState !== this.video.HAVE_ENOUGH_DATA) return;
                
                const quality = this.qualitySelect.value;
                let width, height;
                
                switch (quality) {
                    case 'low':
                        width = 60;
                        height = 40;
                        break;
                    case 'medium':
                        width = 80;
                        height = 50;
                        break;
                    case 'high':
                        width = 120;
                        height = 70;
                        break;
                }
                
                // Adjust canvas size
                this.canvas.width = width;
                this.canvas.height = height;
                
                // Draw video frame to canvas
                this.ctx.drawImage(this.video, 0, 0, width, height);
                
                // Get image data
                const imageData = this.ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // Clear analysis cache for new frame
                this.analysisCache.clear();
                
                // Pre-process image with regional averaging for smoother gradients
                const processedData = this.applyRegionalAveraging(data, width, height);
                
                // Convert to emoji art with enhanced texture and pattern analysis
                this.renderEmojiGrid(processedData, width, height);
                this.adjustFontSize();
            }
            
            renderEmojiGrid(processedData, width, height) {
                // Create a proper grid structure with individual emoji elements
                const gridContainer = document.createElement('div');
                gridContainer.className = 'emoji-grid';
                
                for (let y = 0; y < height; y++) {
                    const row = document.createElement('div');
                    row.className = 'emoji-row';
                    
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const r = processedData[i];
                        const g = processedData[i + 1];
                        const b = processedData[i + 2];
                        
                        // Analyze local texture and patterns
                        const textureInfo = this.analyzeLocalTexture(processedData, x, y, width, height);
                        
                        // Create individual emoji character element
                        const emojiChar = document.createElement('span');
                        emojiChar.className = 'emoji-char';
                        emojiChar.textContent = this.getOptimalEmojiWithTexture(r, g, b, textureInfo, x, y);
                        
                        row.appendChild(emojiChar);
                    }
                    
                    gridContainer.appendChild(row);
                }
                
                // Replace content
                this.emojiOutput.innerHTML = '';
                this.emojiOutput.appendChild(gridContainer);
            }
            
            analyzeLocalTexture(data, x, y, width, height) {
                const cacheKey = `${x},${y}`;
                if (this.analysisCache.has(cacheKey)) {
                    return this.analysisCache.get(cacheKey);
                }
                
                // Sample surrounding pixels for texture analysis
                const radius = 2;
                const samples = [];
                
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const nx = Math.max(0, Math.min(width - 1, x + dx));
                        const ny = Math.max(0, Math.min(height - 1, y + dy));
                        const i = (ny * width + nx) * 4;
                        
                        samples.push({
                            r: data[i],
                            g: data[i + 1],
                            b: data[i + 2],
                            brightness: this.calculatePerceptualBrightness(data[i], data[i + 1], data[i + 2])
                        });
                    }
                }
                
                // Calculate texture metrics
                const brightnessValues = samples.map(s => s.brightness);
                const avgBrightness = brightnessValues.reduce((a, b) => a + b, 0) / brightnessValues.length;
                const brightnessStdDev = Math.sqrt(brightnessValues.reduce((acc, val) => acc + Math.pow(val - avgBrightness, 2), 0) / brightnessValues.length);
                
                // Calculate color variation
                const colorVariation = this.calculateColorVariation(samples);
                
                // Detect edges and gradients
                const edgeStrength = this.calculateEdgeStrength(samples);
                const gradientInfo = this.calculateGradientInfo(samples);
                
                const textureInfo = {
                    variance: brightnessStdDev,
                    colorVariation,
                    edgeStrength,
                    gradientSmoothness: gradientInfo.smoothness,
                    isHighContrast: brightnessStdDev > 40,
                    isSmooth: brightnessStdDev < 15,
                    hasEdge: edgeStrength > 25,
                    isDetailed: colorVariation > 25,
                    hasStrongEdge: edgeStrength > 50,
                    hasMediumEdge: edgeStrength > 25 && edgeStrength <= 50,
                    hasSoftEdge: edgeStrength > 10 && edgeStrength <= 25,
                    isGradientArea: brightnessStdDev < 20 && gradientInfo.smoothness < 15
                };
                
                this.analysisCache.set(cacheKey, textureInfo);
                return textureInfo;
            }
            
            calculateColorVariation(samples) {
                if (samples.length < 2) return 0;
                
                let totalVariation = 0;
                const center = samples[Math.floor(samples.length / 2)];
                
                for (const sample of samples) {
                    const rDiff = Math.abs(sample.r - center.r);
                    const gDiff = Math.abs(sample.g - center.g);
                    const bDiff = Math.abs(sample.b - center.b);
                    totalVariation += (rDiff + gDiff + bDiff) / 3;
                }
                
                return totalVariation / samples.length;
            }
            
            calculateEdgeStrength(samples) {
                if (samples.length < 25) return 0;
                
                // Enhanced Sobel edge detection with proper kernel
                const center = Math.floor(samples.length / 2);
                
                // Sobel X kernel: [-1, 0, 1; -2, 0, 2; -1, 0, 1]
                // Sobel Y kernel: [-1, -2, -1; 0, 0, 0; 1, 2, 1]
                
                let gx = 0, gy = 0;
                
                // Apply Sobel kernels for 5x5 grid
                const sobelX = [
                    [-1, -2, 0, 2, 1],
                    [-2, -3, 0, 3, 2],
                    [-3, -4, 0, 4, 3],
                    [-2, -3, 0, 3, 2],
                    [-1, -2, 0, 2, 1]
                ];
                
                const sobelY = [
                    [-1, -2, -3, -2, -1],
                    [-2, -3, -4, -3, -2],
                    [ 0,  0,  0,  0,  0],
                    [ 2,  3,  4,  3,  2],
                    [ 1,  2,  3,  2,  1]
                ];
                
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 5; j++) {
                        const sampleIndex = i * 5 + j;
                        if (sampleIndex < samples.length) {
                            const brightness = samples[sampleIndex].brightness;
                            gx += sobelX[i][j] * brightness;
                            gy += sobelY[i][j] * brightness;
                        }
                    }
                }
                
                // Calculate gradient magnitude
                return Math.sqrt(gx * gx + gy * gy) / 255;
            }
            
            calculateGradientInfo(samples) {
                if (samples.length < 9) return { smoothness: 0 };
                
                // Calculate how smooth the brightness transition is
                const sortedBrightness = samples.map(s => s.brightness).sort((a, b) => a - b);
                let smoothness = 0;
                
                for (let i = 1; i < sortedBrightness.length; i++) {
                    const diff = sortedBrightness[i] - sortedBrightness[i - 1];
                    smoothness += diff;
                }
                
                return {
                    smoothness: smoothness / (sortedBrightness.length - 1)
                };
            }
            
            getOptimalEmojiWithTexture(r, g, b, textureInfo, x, y) {
                // Calculate perceptual brightness
                const brightness = this.calculatePerceptualBrightness(r, g, b);
                
                // Get neighborhood context for anti-clustering
                const neighborhood = this.getNeighborhoodContext(x, y);
                
                // Get texture and detail information for emoji variation
                const entropy = this.calculateLocalEntropy(textureInfo);
                
                // Select green emoji based on brightness and texture
                let selectedEmoji = this.getGreenEmojiByBrightness(brightness, textureInfo, neighborhood, entropy, x, y);
                
                // Track emoji usage to prevent excessive repetition
                this.updateEmojiUsage(selectedEmoji, x, y);
                
                return selectedEmoji;
            }
            
            getEdgeBasedEmoji(brightness, edgeStrength, colorInfo, neighborhood) {
                // Select appropriate edge emoji based on strength and color
                if (colorInfo.hasStrongColor) {
                    const colorEdges = this.edgeEmojis.coloredStrong[colorInfo.dominantColor];
                    if (colorEdges) {
                        return this.selectFromCollectionWithAntiClustering(colorEdges, neighborhood, brightness);
                    }
                }
                
                // Use grayscale edges based on strength
                let edgeCategory;
                if (edgeStrength > 60) {
                    edgeCategory = this.edgeEmojis.strong;
                } else if (edgeStrength > 30) {
                    edgeCategory = this.edgeEmojis.medium;
                } else {
                    edgeCategory = this.edgeEmojis.soft;
                }
                
                return this.selectFromCollectionWithAntiClustering(edgeCategory, neighborhood, brightness);
            }
            
            getOptimalEmoji(r, g, b) {
                // Fallback method for compatibility
                return this.getOptimalEmojiWithTexture(r, g, b, { 
                    variance: 0, 
                    colorVariation: 0, 
                    edgeStrength: 0, 
                    gradientSmoothness: 0, 
                    isHighContrast: false, 
                    isSmooth: true, 
                    hasEdge: false, 
                    isDetailed: false 
                });
            }
            
            applyRegionalAveraging(data, width, height) {
                const processedData = new Uint8ClampedArray(data.length);
                const smoothingRadius = 1; // Radius for regional averaging
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        
                        // Calculate average color in local region
                        const regionAverage = this.calculateRegionAverage(data, x, y, width, height, smoothingRadius);
                        
                        // Check if this pixel should be smoothed based on local variance
                        const localVariance = this.calculateLocalVariance(data, x, y, width, height, smoothingRadius);
                        
                        // Apply smoothing only to areas with low edge strength and high noise
                        if (localVariance < 30) { // Low variance areas get smoothed
                            const blendFactor = 0.6; // How much to blend with region average
                            processedData[i] = Math.round(data[i] * (1 - blendFactor) + regionAverage.r * blendFactor);
                            processedData[i + 1] = Math.round(data[i + 1] * (1 - blendFactor) + regionAverage.g * blendFactor);
                            processedData[i + 2] = Math.round(data[i + 2] * (1 - blendFactor) + regionAverage.b * blendFactor);
                        } else {
                            // Keep original values for high-variance areas (preserves edges)
                            processedData[i] = data[i];
                            processedData[i + 1] = data[i + 1];
                            processedData[i + 2] = data[i + 2];
                        }
                        
                        processedData[i + 3] = data[i + 3]; // Keep alpha channel unchanged
                    }
                }
                
                return processedData;
            }
            
            calculateRegionAverage(data, x, y, width, height, radius) {
                let rSum = 0, gSum = 0, bSum = 0, count = 0;
                
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const nx = Math.max(0, Math.min(width - 1, x + dx));
                        const ny = Math.max(0, Math.min(height - 1, y + dy));
                        const i = (ny * width + nx) * 4;
                        
                        rSum += data[i];
                        gSum += data[i + 1];
                        bSum += data[i + 2];
                        count++;
                    }
                }
                
                return {
                    r: rSum / count,
                    g: gSum / count,
                    b: bSum / count
                };
            }
            
            calculateLocalVariance(data, x, y, width, height, radius) {
                const center = {
                    r: data[(y * width + x) * 4],
                    g: data[(y * width + x) * 4 + 1],
                    b: data[(y * width + x) * 4 + 2]
                };
                
                let varianceSum = 0;
                let count = 0;
                
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const nx = Math.max(0, Math.min(width - 1, x + dx));
                        const ny = Math.max(0, Math.min(height - 1, y + dy));
                        const i = (ny * width + nx) * 4;
                        
                        const rDiff = data[i] - center.r;
                        const gDiff = data[i + 1] - center.g;
                        const bDiff = data[i + 2] - center.b;
                        
                        varianceSum += (rDiff * rDiff + gDiff * gDiff + bDiff * bDiff) / 3;
                        count++;
                    }
                }
                
                return Math.sqrt(varianceSum / count);
            }
            
            getGradientBasedEmoji(brightness, colorInfo, gradientSmoothness, neighborhood) {
                // For very smooth gradients, use emojis that blend well
                const smoothEmojis = this.textureEmojis.smooth;
                
                if (colorInfo.hasStrongColor) {
                    const colorData = this.colorEmojiMap[colorInfo.dominantColor];
                    if (colorData) {
                        // Select from appropriate brightness category
                        let brightnessCategory;
                        if (brightness < 51) {
                            brightnessCategory = 'veryDark';
                        } else if (brightness < 102) {
                            brightnessCategory = 'dark';
                        } else if (brightness < 153) {
                            brightnessCategory = 'medium';
                        } else if (brightness < 204) {
                            brightnessCategory = 'light';
                        } else {
                            brightnessCategory = 'veryLight';
                        }
                        
                        const categoryEmojis = colorData[brightnessCategory];
                        if (categoryEmojis && categoryEmojis.length > 0) {
                            return this.selectFromCollectionWithAntiClustering(categoryEmojis, neighborhood, brightness);
                        }
                    }
                }
                
                // Fallback to smooth texture emojis
                return this.selectFromCollectionWithAntiClustering(smoothEmojis, neighborhood, brightness);
            }
            
            calculateLocalEntropy(textureInfo) {
                // Higher entropy indicates more detail and variation
                const variance = textureInfo.variance || 0;
                const colorVariation = textureInfo.colorVariation || 0;
                const edgeStrength = textureInfo.edgeStrength || 0;
                
                // Normalize and combine factors
                const normalizedVariance = Math.min(variance / 50, 1);
                const normalizedColorVar = Math.min(colorVariation / 40, 1);
                const normalizedEdge = Math.min(edgeStrength / 60, 1);
                
                return (normalizedVariance + normalizedColorVar + normalizedEdge) / 3;
            }
            
            getNeighborhoodContext(x, y) {
                const radius = 2;
                const recentEmojis = [];
                
                // Check recently used emojis in the area
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const key = `${x + dx},${y + dy}`;
                        if (this.lastUsedEmojis.has(key)) {
                            recentEmojis.push(this.lastUsedEmojis.get(key));
                        }
                    }
                }
                
                return {
                    recentEmojis,
                    count: recentEmojis.length,
                    diversity: new Set(recentEmojis).size
                };
            }
            
            getDetailedEmoji(brightness, colorInfo, neighborhood, entropy) {
                // Use different categories based on entropy level
                let category, subcategory;
                
                if (entropy > 0.9) {
                    category = this.detailedEmojiMap.objects;
                } else if (entropy > 0.8) {
                    category = this.detailedEmojiMap.nature;
                } else {
                    category = this.detailedEmojiMap.animals;
                }
                
                // Select brightness subcategory
                if (brightness < 85) {
                    subcategory = category.dark;
                } else if (brightness < 170) {
                    subcategory = category.medium;
                } else {
                    subcategory = category.light;
                }
                
                return this.selectFromCollectionWithAntiClustering(subcategory, neighborhood, brightness);
            }
            
            detectFaceRegion(textureInfo, colorInfo) {
                // Simple heuristic for face-like regions
                const isFleshTone = colorInfo.dominantColor === 'orange' || 
                                   colorInfo.dominantColor === 'brown' || 
                                   colorInfo.dominantColor === 'pink';
                const hasModerateDetail = textureInfo.variance > 15 && textureInfo.variance < 40;
                const hasSoftEdges = textureInfo.edgeStrength > 10 && textureInfo.edgeStrength < 35;
                
                return isFleshTone && hasModerateDetail && hasSoftEdges;
            }
            
            getFaceBasedEmoji(brightness, colorInfo, neighborhood) {
                let subcategory;
                
                if (brightness < 85) {
                    subcategory = this.detailedEmojiMap.faces.dark;
                } else if (brightness < 170) {
                    subcategory = this.detailedEmojiMap.faces.medium;
                } else {
                    subcategory = this.detailedEmojiMap.faces.light;
                }
                
                return this.selectFromCollectionWithAntiClustering(subcategory, neighborhood, brightness);
            }
            
            detectOrganicShape(textureInfo, colorInfo) {
                // Detect organic, flowing shapes
                const hasOrganicColor = colorInfo.dominantColor === 'green' || 
                                       colorInfo.dominantColor === 'brown' || 
                                       colorInfo.dominantColor === 'blue';
                const hasFlowingTexture = textureInfo.gradientSmoothness > 8 && textureInfo.variance > 20;
                const hasModerateEdges = textureInfo.edgeStrength > 15 && textureInfo.edgeStrength < 45;
                
                return hasOrganicColor && (hasFlowingTexture || hasModerateEdges);
            }
            
            getOrganicEmoji(brightness, colorInfo, neighborhood) {
                let category;
                
                // Choose category based on color
                if (colorInfo.dominantColor === 'green') {
                    category = this.detailedEmojiMap.nature;
                } else {
                    category = this.detailedEmojiMap.animals;
                }
                
                let subcategory;
                if (brightness < 85) {
                    subcategory = category.dark;
                } else if (brightness < 170) {
                    subcategory = category.medium;
                } else {
                    subcategory = category.light;
                }
                
                return this.selectFromCollectionWithAntiClustering(subcategory, neighborhood, brightness);
            }
            
            getVariedBrightnessEmoji(brightness, neighborhood) {
                // Mix different emoji types for varied representation
                const categories = [
                    this.detailedEmojiMap.objects,
                    this.detailedEmojiMap.nature,
                    this.detailedEmojiMap.animals
                ];
                
                const category = categories[Math.floor(Math.random() * categories.length)];
                
                let subcategory;
                if (brightness < 85) {
                    subcategory = category.dark;
                } else if (brightness < 170) {
                    subcategory = category.medium;
                } else {
                    subcategory = category.light;
                }
                
                return this.selectFromCollectionWithAntiClustering(subcategory, neighborhood, brightness);
            }
            
            selectFromCollectionWithAntiClustering(collection, neighborhood, brightness) {
                if (!collection || collection.length === 0) {
                    return 'âšª'; // Fallback
                }
                
                // Filter out recently used emojis in the neighborhood
                let availableEmojis = collection.filter(emoji => 
                    !neighborhood.recentEmojis.includes(emoji)
                );
                
                // If all emojis are recently used, use the full collection but prefer less used ones
                if (availableEmojis.length === 0) {
                    availableEmojis = collection;
                }
                
                // Add some randomness based on brightness for more variety
                const brightnessVariation = Math.floor((brightness % 30) / 6);
                const baseIndex = Math.floor((brightness / 255) * (availableEmojis.length - 1));
                const finalIndex = (baseIndex + brightnessVariation) % availableEmojis.length;
                
                return availableEmojis[finalIndex];
            }
            
            selectGreenEmojiWithStyle(emojiCategory, textureInfo, neighborhood, entropy, brightness, x, y) {
                if (!emojiCategory || emojiCategory.length === 0) {
                    return 'ðŸŸ¢'; // Fallback green circle
                }
                
                // Add stylistic variation based on different factors
                let styleIndex = 0;
                
                // Factor 1: Texture-based selection
                if (textureInfo.hasEdge || textureInfo.edgeStrength > 25) {
                    // Use more geometric/structured emojis for edges
                    styleIndex += Math.floor(entropy * 3);
                } else if (textureInfo.isSmooth) {
                    // Use organic/flowing emojis for smooth areas
                    styleIndex += Math.floor((1 - entropy) * 2);
                }
                
                // Factor 2: Brightness micro-variation within category
                const brightnessVariation = brightness % 15;
                styleIndex += Math.floor(brightnessVariation / 3);
                
                // Factor 3: Position-based pseudo-randomness for texture
                const positionSeed = (x * 7 + y * 11) % 5;
                styleIndex += positionSeed;
                
                // Factor 4: Frame-based temporal variation
                this.frameCounter = (this.frameCounter + 1) % 1000;
                const temporalVariation = Math.floor(this.frameCounter / 10) % 3;
                styleIndex += temporalVariation;
                
                // Factor 5: Anti-clustering with more aggressive diversity
                let availableEmojis = emojiCategory.filter(emoji => 
                    !neighborhood.recentEmojis.includes(emoji)
                );
                
                // If too many filtered out, use the full collection
                if (availableEmojis.length < 3) {
                    availableEmojis = emojiCategory;
                }
                
                // Select final emoji with all style factors
                const finalIndex = styleIndex % availableEmojis.length;
                return availableEmojis[finalIndex];
            }
            
            getBrightnessCategory(brightness) {
                if (brightness < 51) {
                    return 'veryDark';
                } else if (brightness < 102) {
                    return 'dark';
                } else if (brightness < 153) {
                    return 'medium';
                } else if (brightness < 204) {
                    return 'light';
                } else {
                    return 'veryLight';
                }
            }
            
            getGrayscaleEmoji(brightness, neighborhood) {
                const brightnessCategory = this.getBrightnessCategory(brightness);
                
                let grayEmojis;
                if (brightness < 85) {
                    grayEmojis = this.solidColorEmojis.black[brightnessCategory];
                } else if (brightness > 170) {
                    grayEmojis = this.solidColorEmojis.white[brightnessCategory];
                } else {
                    grayEmojis = this.solidColorEmojis.gray[brightnessCategory];
                }
                
                return this.selectFromCollectionWithAntiClustering(grayEmojis || ['âš«'], neighborhood, brightness);
            }
            
            updateEmojiUsage(emoji, x, y) {
                const key = `${x},${y}`;
                this.lastUsedEmojis.set(key, emoji);
                
                // Track overall usage
                const count = this.emojiUsageMap.get(emoji) || 0;
                this.emojiUsageMap.set(emoji, count + 1);
                
                // Clean up old entries to prevent memory issues
                if (this.lastUsedEmojis.size > 10000) {
                    const entries = Array.from(this.lastUsedEmojis.entries());
                    entries.slice(0, 5000).forEach(([key]) => {
                        this.lastUsedEmojis.delete(key);
                    });
                }
            }
            
            calculatePerceptualBrightness(r, g, b) {
                // Enhanced perceptual brightness using sRGB luminance
                const linearR = this.gammaCorrect(r / 255);
                const linearG = this.gammaCorrect(g / 255);
                const linearB = this.gammaCorrect(b / 255);
                
                // ITU-R BT.709 luma coefficients
                return (0.2126 * linearR + 0.7152 * linearG + 0.0722 * linearB) * 255;
            }
            
            gammaCorrect(value) {
                return value <= 0.04045 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
            }
            
            calculateSaturation(r, g, b) {
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                return max === 0 ? 0 : (max - min) / max;
            }
            
            calculateChroma(r, g, b) {
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                return max - min;
            }
            
            calculateHue(r, g, b) {
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;
                
                if (delta === 0) return 0;
                
                let hue;
                if (max === r) {
                    hue = ((g - b) / delta) % 6;
                } else if (max === g) {
                    hue = (b - r) / delta + 2;
                } else {
                    hue = (r - g) / delta + 4;
                }
                
                return hue * 60;
            }
            
            getAdvancedColorInfo(r, g, b) {
                const hue = this.calculateHue(r, g, b);
                const saturation = this.calculateSaturation(r, g, b);
                const chroma = this.calculateChroma(r, g, b);
                const brightness = this.calculatePerceptualBrightness(r, g, b);
                
                // Multiple criteria for color strength
                const hasStrongSaturation = saturation > 0.35;
                const hasStrongChroma = chroma > 40;
                const hasMinimumBrightness = brightness > 30;
                const hasStrongColor = hasStrongSaturation && hasStrongChroma && hasMinimumBrightness;
                
                if (!hasStrongColor) {
                    return { hasStrongColor: false, dominantColor: 'white' };
                }
                
                // Improved hue-based color detection with more accurate ranges
                let dominantColor;
                const normalizedHue = hue < 0 ? hue + 360 : hue;
                
                if (normalizedHue >= 345 || normalizedHue < 15) {
                    dominantColor = 'red';
                } else if (normalizedHue >= 15 && normalizedHue < 45) {
                    dominantColor = 'orange';
                } else if (normalizedHue >= 45 && normalizedHue < 75) {
                    dominantColor = 'yellow';
                } else if (normalizedHue >= 75 && normalizedHue < 150) {
                    dominantColor = 'green';
                } else if (normalizedHue >= 150 && normalizedHue < 250) {
                    dominantColor = 'blue';
                } else if (normalizedHue >= 250 && normalizedHue < 290) {
                    dominantColor = 'purple';
                } else if (normalizedHue >= 290 && normalizedHue < 345) {
                    // Check for pink vs purple based on saturation and brightness
                    if (saturation < 0.6 && brightness > 180) {
                        dominantColor = 'pink';
                    } else {
                        dominantColor = 'purple';
                    }
                } else {
                    dominantColor = 'white';
                }
                
                // Special handling for brown (low saturation, mid brightness, orange-ish hue)
                if ((normalizedHue >= 15 && normalizedHue < 45) && saturation < 0.6 && brightness < 120) {
                    dominantColor = 'brown';
                }
                
                // Special handling for black/dark colors
                if (brightness < 50 && saturation < 0.3) {
                    dominantColor = 'black';
                }
                
                return {
                    hasStrongColor,
                    dominantColor,
                    hue: normalizedHue,
                    saturation,
                    chroma,
                    brightness
                };
            }
            
            getGreenEmojiByBrightness(brightness, textureInfo, neighborhood, entropy, x, y) {
                // Map brightness to green emoji categories with fine granularity
                let emojiCategory;
                
                if (brightness >= 240) {
                    emojiCategory = this.greenEmojis.ultraBright;
                } else if (brightness >= 210) {
                    emojiCategory = this.greenEmojis.veryBright;
                } else if (brightness >= 180) {
                    emojiCategory = this.greenEmojis.bright;
                } else if (brightness >= 150) {
                    emojiCategory = this.greenEmojis.mediumBright;
                } else if (brightness >= 120) {
                    emojiCategory = this.greenEmojis.medium;
                } else if (brightness >= 90) {
                    emojiCategory = this.greenEmojis.mediumDark;
                } else if (brightness >= 60) {
                    emojiCategory = this.greenEmojis.dark;
                } else if (brightness >= 30) {
                    emojiCategory = this.greenEmojis.veryDark;
                } else {
                    emojiCategory = this.greenEmojis.ultraDark;
                }
                
                return this.selectGreenEmojiWithStyle(emojiCategory, textureInfo, neighborhood, entropy, brightness, x, y);
            }
            
            getBrightnessBasedEmoji(brightness) {
                // Find appropriate brightness category
                for (const range of this.brightnessRanges) {
                    if (brightness >= range.min && brightness < range.max) {
                        const categoryEmojis = this.emojiMap[range.category];
                        const normalizedBrightness = (brightness - range.min) / (range.max - range.min);
                        const index = Math.floor(normalizedBrightness * (categoryEmojis.length - 1));
                        return categoryEmojis[Math.max(0, Math.min(index, categoryEmojis.length - 1))];
                    }
                }
                
                // Fallback to very light for maximum brightness
                const veryLight = this.emojiMap.veryLight;
                return veryLight[veryLight.length - 1];
            }
            
            adjustFontSize() {
                const containerWidth = this.emojiOutput.clientWidth;
                const containerHeight = this.emojiOutput.clientHeight;
                
                const quality = this.qualitySelect.value;
                let targetWidth, targetHeight;
                
                switch (quality) {
                    case 'low': 
                        targetWidth = 60; 
                        targetHeight = 40; 
                        break;
                    case 'medium': 
                        targetWidth = 80; 
                        targetHeight = 50; 
                        break;
                    case 'high': 
                        targetWidth = 120; 
                        targetHeight = 70; 
                        break;
                }
                
                // Calculate optimal font size based on cell dimensions (1.2em per cell)
                const maxWidthPerChar = containerWidth / targetWidth / 1.2;
                const maxHeightPerChar = containerHeight / targetHeight / 1.2;
                
                // Use the smaller of width/height constraints to ensure fit
                const fontSize = Math.max(4, Math.min(maxWidthPerChar, maxHeightPerChar, 24));
                
                this.emojiOutput.style.fontSize = fontSize + 'px';
                
                // Update CSS variables for grid sizing
                const gridContainer = this.emojiOutput.querySelector('.emoji-grid');
                if (gridContainer) {
                    gridContainer.style.fontSize = fontSize + 'px';
                }
            }
            
            takeSnapshot() {
                if (!this.stream) return;
                
                // Create a larger canvas for the snapshot
                const snapshotCanvas = document.createElement('canvas');
                const snapshotCtx = snapshotCanvas.getContext('2d');
                
                const width = 160;
                const height = 120;
                
                snapshotCanvas.width = width;
                snapshotCanvas.height = height;
                
                // Draw current frame
                snapshotCtx.drawImage(this.video, 0, 0, width, height);
                
                // Get image data and convert to emoji using enhanced mapping
                const imageData = snapshotCtx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                let emojiArt = '';
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        emojiArt += this.getOptimalEmoji(r, g, b);
                    }
                    emojiArt += '\n';
                }
                
                // Create and download the snapshot
                const blob = new Blob([emojiArt], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `emoji-snapshot-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            handleResize() {
                // Adjust font size when window is resized
                if (this.stream) {
                    setTimeout(() => this.adjustFontSize(), 100);
                }
            }
            
            updateUI(isActive) {
                this.startBtn.disabled = isActive;
                this.stopBtn.disabled = !isActive;
                this.snapshotBtn.disabled = !isActive;
            }
            
            showStatus(message, type = '') {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                this.status.style.display = 'block';
            }
            
            hideStatus() {
                this.status.style.display = 'none';
            }
        }
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            new EmojiVision();
        });
    </script>
</body>
</html>