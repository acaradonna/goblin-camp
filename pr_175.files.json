[
  {
    "sha": "89c8da3e389f505571d919b2ee11f558c24d5b44",
    "filename": "crates/gc_core/src/components.rs",
    "status": "modified",
    "additions": 373,
    "deletions": 0,
    "changes": 373,
    "blob_url": "https://github.com/acaradonna/goblin-camp/blob/e146953ec3ada39e74bae4926b761da4a78158dd/crates%2Fgc_core%2Fsrc%2Fcomponents.rs",
    "raw_url": "https://github.com/acaradonna/goblin-camp/raw/e146953ec3ada39e74bae4926b761da4a78158dd/crates%2Fgc_core%2Fsrc%2Fcomponents.rs",
    "contents_url": "https://api.github.com/repos/acaradonna/goblin-camp/contents/crates%2Fgc_core%2Fsrc%2Fcomponents.rs?ref=e146953ec3ada39e74bae4926b761da4a78158dd",
    "patch": "@@ -159,3 +159,376 @@ pub struct Stockpile {\n     /// When None, all item types are accepted (current MVP behavior)\n     pub accepts: Option<Vec<ItemType>>,\n }\n+\n+// ============================================================================\n+// Combat MVP Components\n+// ============================================================================\n+\n+/// Faction types for combat and social interactions\n+/// Determines hostility and targeting behavior between entities\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n+pub enum FactionKind {\n+    /// Player-controlled goblins and allies\n+    Goblins,\n+    /// Hostile invaders and enemies\n+    Invaders,\n+    /// Neutral entities that don't participate in combat\n+    Neutral,\n+}\n+\n+/// Component defining an entity's faction allegiance\n+/// Used to determine hostility and targeting in combat systems\n+#[derive(Component, Debug, Clone, Serialize, Deserialize)]\n+pub struct Faction {\n+    /// The faction this entity belongs to\n+    pub kind: FactionKind,\n+}\n+\n+impl Faction {\n+    /// Create a new faction component\n+    pub fn new(kind: FactionKind) -> Self {\n+        Self { kind }\n+    }\n+\n+    /// Check if this faction is hostile to another faction\n+    pub fn is_hostile_to(&self, other: &Faction) -> bool {\n+        matches!(\n+            (self.kind, other.kind),\n+            (FactionKind::Goblins, FactionKind::Invaders)\n+                | (FactionKind::Invaders, FactionKind::Goblins)\n+        )\n+    }\n+}\n+\n+/// Component representing an entity's health and vitality\n+/// Tracks current and maximum hit points for combat and survival\n+#[derive(Component, Debug, Clone, Serialize, Deserialize)]\n+pub struct Health {\n+    /// Current hit points (0 = dead)\n+    pub hp: i32,\n+    /// Maximum hit points this entity can have\n+    pub max_hp: i32,\n+}\n+\n+impl Health {\n+    /// Create a new health component with specified values\n+    /// Automatically clamps hp to valid range [0, max_hp]\n+    pub fn new(hp: i32, max_hp: i32) -> Self {\n+        let max_hp = max_hp.max(0);\n+        let hp = hp.clamp(0, max_hp);\n+        Self { hp, max_hp }\n+    }\n+\n+    /// Create a new health component with full health\n+    pub fn full(max_hp: i32) -> Self {\n+        Self::new(max_hp, max_hp)\n+    }\n+\n+    /// Check if the entity is alive (hp > 0)\n+    pub fn is_alive(&self) -> bool {\n+        self.hp > 0\n+    }\n+\n+    /// Check if the entity is dead (hp <= 0)\n+    pub fn is_dead(&self) -> bool {\n+        self.hp <= 0\n+    }\n+\n+    /// Apply damage to the entity, clamping to 0\n+    /// Returns the actual damage dealt\n+    pub fn take_damage(&mut self, damage: i32) -> i32 {\n+        let old_hp = self.hp;\n+        self.hp = (self.hp - damage).clamp(0, self.max_hp);\n+        old_hp - self.hp\n+    }\n+\n+    /// Heal the entity, clamping to max_hp\n+    /// Returns the actual healing applied\n+    pub fn heal(&mut self, amount: i32) -> i32 {\n+        let old_hp = self.hp;\n+        self.hp = (self.hp + amount).clamp(0, self.max_hp);\n+        self.hp - old_hp\n+    }\n+\n+    /// Get the percentage of health remaining (0.0 to 1.0)\n+    pub fn health_percentage(&self) -> f32 {\n+        if self.max_hp == 0 {\n+            0.0\n+        } else {\n+            self.hp as f32 / self.max_hp as f32\n+        }\n+    }\n+}\n+\n+/// Component defining an entity's combat capabilities and statistics\n+/// Used for attack resolution, damage calculation, and combat mechanics\n+#[derive(Component, Debug, Clone, Serialize, Deserialize)]\n+pub struct CombatStats {\n+    /// Accuracy bonus for attack rolls (higher = more likely to hit)\n+    pub accuracy: i32,\n+    /// Evasion bonus for defense rolls (higher = harder to hit)\n+    pub evasion: i32,\n+    /// Attack power for damage calculation\n+    pub attack: i32,\n+    /// Defense value that reduces incoming damage\n+    pub defense: i32,\n+    /// Minimum damage dealt on successful hit\n+    pub dmg_min: i32,\n+    /// Maximum damage dealt on successful hit\n+    pub dmg_max: i32,\n+}\n+\n+impl CombatStats {\n+    /// Create new combat stats with validation\n+    /// Ensures dmg_min <= dmg_max and all stats are non-negative\n+    pub fn new(\n+        accuracy: i32,\n+        evasion: i32,\n+        attack: i32,\n+        defense: i32,\n+        dmg_min: i32,\n+        dmg_max: i32,\n+    ) -> Self {\n+        let (dmg_min, dmg_max) = if dmg_min <= dmg_max {\n+            (dmg_min, dmg_max)\n+        } else {\n+            (dmg_max, dmg_min)\n+        };\n+\n+        Self {\n+            accuracy: accuracy.max(0),\n+            evasion: evasion.max(0),\n+            attack: attack.max(0),\n+            defense: defense.max(0),\n+            dmg_min: dmg_min.max(0),\n+            dmg_max: dmg_max.max(0),\n+        }\n+    }\n+\n+    /// Calculate the base hit chance percentage (0-100)\n+    /// Higher accuracy vs evasion increases hit chance\n+    pub fn hit_chance(&self) -> i32 {\n+        let base = 50 + (self.accuracy - self.evasion) * 5;\n+        base.clamp(5, 95)\n+    }\n+}\n+\n+/// Component tracking attack cooldown timing\n+/// Prevents entities from attacking too frequently\n+#[derive(Component, Debug, Clone, Serialize, Deserialize)]\n+pub struct AttackCooldown {\n+    /// Tick number when the entity can attack again\n+    /// When current tick >= until_tick, attack is allowed\n+    pub until_tick: u64,\n+}\n+\n+impl AttackCooldown {\n+    /// Create a new cooldown that expires at the specified tick\n+    pub fn new(until_tick: u64) -> Self {\n+        Self { until_tick }\n+    }\n+\n+    /// Check if the cooldown has expired at the current tick\n+    pub fn is_ready(&self, current_tick: u64) -> bool {\n+        current_tick >= self.until_tick\n+    }\n+\n+    /// Set the cooldown to expire after the specified number of ticks\n+    pub fn set_duration(&mut self, current_tick: u64, duration_ticks: u64) {\n+        self.until_tick = current_tick + duration_ticks;\n+    }\n+}\n+\n+/// Marker component indicating an entity can participate in combat\n+/// Entities with this component can attack, be attacked, and use combat systems\n+#[derive(Component, Debug, Serialize, Deserialize)]\n+pub struct Combatant;\n+\n+/// Marker component indicating an entity is dead\n+/// Dead entities should not participate in combat, movement, or jobs\n+#[derive(Component, Debug, Serialize, Deserialize)]\n+pub struct Dead;\n+\n+/// Component for targeting other entities in combat\n+/// Lightweight pointer to the target entity for combat systems\n+#[derive(Component, Debug, Clone)]\n+pub struct Target {\n+    /// The entity being targeted\n+    pub entity: Entity,\n+}\n+\n+impl Target {\n+    /// Create a new target component\n+    pub fn new(entity: Entity) -> Self {\n+        Self { entity }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use bevy_ecs::entity::Entity;\n+\n+    #[test]\n+    fn faction_hostility_rules() {\n+        let goblins = Faction::new(FactionKind::Goblins);\n+        let invaders = Faction::new(FactionKind::Invaders);\n+        let neutral = Faction::new(FactionKind::Neutral);\n+\n+        // Goblins and Invaders are hostile to each other\n+        assert!(goblins.is_hostile_to(&invaders));\n+        assert!(invaders.is_hostile_to(&goblins));\n+\n+        // Neutral entities are not hostile to anyone\n+        assert!(!neutral.is_hostile_to(&goblins));\n+        assert!(!neutral.is_hostile_to(&invaders));\n+        assert!(!neutral.is_hostile_to(&neutral));\n+\n+        // Goblins are not hostile to themselves\n+        assert!(!goblins.is_hostile_to(&goblins));\n+    }\n+\n+    #[test]\n+    fn health_creation_and_validation() {\n+        // Test normal creation\n+        let health = Health::new(75, 100);\n+        assert_eq!(health.hp, 75);\n+        assert_eq!(health.max_hp, 100);\n+\n+        // Test clamping to max_hp\n+        let health = Health::new(150, 100);\n+        assert_eq!(health.hp, 100);\n+        assert_eq!(health.max_hp, 100);\n+\n+        // Test clamping to 0\n+        let health = Health::new(-10, 100);\n+        assert_eq!(health.hp, 0);\n+        assert_eq!(health.max_hp, 100);\n+\n+        // Test full health constructor\n+        let health = Health::full(50);\n+        assert_eq!(health.hp, 50);\n+        assert_eq!(health.max_hp, 50);\n+    }\n+\n+    #[test]\n+    fn health_life_death_checks() {\n+        let mut health = Health::new(50, 100);\n+\n+        // Should be alive\n+        assert!(health.is_alive());\n+        assert!(!health.is_dead());\n+\n+        // Take damage but stay alive\n+        let damage_dealt = health.take_damage(30);\n+        assert_eq!(damage_dealt, 30);\n+        assert_eq!(health.hp, 20);\n+        assert!(health.is_alive());\n+\n+        // Take lethal damage\n+        let damage_dealt = health.take_damage(50);\n+        assert_eq!(damage_dealt, 20);\n+        assert_eq!(health.hp, 0);\n+        assert!(health.is_dead());\n+        assert!(!health.is_alive());\n+    }\n+\n+    #[test]\n+    fn health_healing() {\n+        let mut health = Health::new(20, 100);\n+\n+        // Heal normally\n+        let healing_applied = health.heal(30);\n+        assert_eq!(healing_applied, 30);\n+        assert_eq!(health.hp, 50);\n+\n+        // Heal beyond max_hp (should clamp)\n+        let healing_applied = health.heal(100);\n+        assert_eq!(healing_applied, 50);\n+        assert_eq!(health.hp, 100);\n+    }\n+\n+    #[test]\n+    fn health_percentage() {\n+        let health = Health::new(75, 100);\n+        assert_eq!(health.health_percentage(), 0.75);\n+\n+        let health = Health::new(0, 100);\n+        assert_eq!(health.health_percentage(), 0.0);\n+\n+        let health = Health::new(100, 100);\n+        assert_eq!(health.health_percentage(), 1.0);\n+\n+        // Edge case: max_hp = 0\n+        let health = Health::new(0, 0);\n+        assert_eq!(health.health_percentage(), 0.0);\n+    }\n+\n+    #[test]\n+    fn combat_stats_validation() {\n+        // Test normal creation\n+        let stats = CombatStats::new(10, 5, 15, 8, 20, 30);\n+        assert_eq!(stats.accuracy, 10);\n+        assert_eq!(stats.evasion, 5);\n+        assert_eq!(stats.attack, 15);\n+        assert_eq!(stats.defense, 8);\n+        assert_eq!(stats.dmg_min, 20);\n+        assert_eq!(stats.dmg_max, 30);\n+\n+        // Test negative stat clamping\n+        let stats = CombatStats::new(-5, -3, -10, -2, 15, 25);\n+        assert_eq!(stats.accuracy, 0);\n+        assert_eq!(stats.evasion, 0);\n+        assert_eq!(stats.attack, 0);\n+        assert_eq!(stats.defense, 0);\n+        assert_eq!(stats.dmg_min, 15);\n+        assert_eq!(stats.dmg_max, 25);\n+\n+        // Test damage range validation\n+        let stats = CombatStats::new(5, 3, 10, 5, 30, 20);\n+        assert_eq!(stats.dmg_min, 20);\n+        assert_eq!(stats.dmg_max, 30);\n+    }\n+\n+    #[test]\n+    fn combat_stats_hit_chance() {\n+        let stats = CombatStats::new(10, 5, 15, 8, 20, 30);\n+\n+        // Base hit chance should be 50 + (10 - 5) * 5 = 75\n+        assert_eq!(stats.hit_chance(), 75);\n+\n+        // High accuracy vs low evasion\n+        let stats = CombatStats::new(20, 0, 15, 8, 20, 30);\n+        assert_eq!(stats.hit_chance(), 95); // Clamped to max\n+\n+        // Low accuracy vs high evasion\n+        let stats = CombatStats::new(0, 20, 15, 8, 20, 30);\n+        assert_eq!(stats.hit_chance(), 5); // Clamped to min\n+    }\n+\n+    #[test]\n+    fn attack_cooldown_timing() {\n+        let mut cooldown = AttackCooldown::new(100);\n+\n+        // Should not be ready before the tick\n+        assert!(!cooldown.is_ready(50));\n+        assert!(!cooldown.is_ready(99));\n+\n+        // Should be ready at and after the tick\n+        assert!(cooldown.is_ready(100));\n+        assert!(cooldown.is_ready(150));\n+\n+        // Test setting duration\n+        cooldown.set_duration(200, 50);\n+        assert_eq!(cooldown.until_tick, 250);\n+        assert!(!cooldown.is_ready(200));\n+        assert!(cooldown.is_ready(250));\n+    }\n+\n+    #[test]\n+    fn target_creation() {\n+        let entity = Entity::from_raw(42);\n+        let target = Target::new(entity);\n+        assert_eq!(target.entity, entity);\n+    }\n+}"
  }
]
